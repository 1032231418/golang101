<!---
annotation reflect functions can be used in
* reflect.Type.Elem(): get element type
* reflect.Type.Key(): get key type
* 


type composition examples
* chan chan chan in
* func() func() func()
* ....
-->

<p>
This article will introduce all kinds of types supported in Go
and all kinds of concepts in Go type system.
Many of these concepts are similiar with many other popular programming languages,
but there are also some unique concpets in Go.
Without knowing these concepts, it is hard to have a thorough understanding of Go.
</p>

<p><i>
(This article will not explain some very basic knowledges,
such as what are types and functions.)
</i></p>

<h3>Concept: Built-in Basic Types</h3>

<div>
Built-in basic types in Go: 
<ul>
<li><code>bool</code></li>
<li><code>int8</code>, <code>uint8</code> (<code>byte</code>), <code>int16</code>, <code>uint16</code>, <code>int32</code> (<code>rune</code>), <code>uint32</code>, <code>int64</code>, <code>uint64</code>, <code>int</code>, <code>uint</code>, <code>uinptr</code></li>
<li><code>float32</code>, <code>float64</code></li>
<li><code>complex64</code>, <code>complex128</code></li>
<li><code>string</code></li>
</ul>

<p>
NOTE: <code>byte</code> is a built-in alias of <code>uint8</code>,
they are the same type in fact.
The same relation is for <code>rune</code> and <code>int32</code>.
</p>

<p>
The types whose names starting with an <code>u</code> are unsigned (non-negative) types.
</p>

<p>
Except <a href="golang-string">string types</a>,
Go 101 article series will try to explain other basic types in detail.
</p>
</div>

<h3>Concept: Composite Types</h3>

<div>
Go supports following composite types:
<ul>
<li><a href="golang-pointer">pointer types</a> - C pointer alike.</li>
<li><a href="golang-struct">struct types</a> - C struct alike.</li>
<li><a href="golang-function">function types</a> - functions are first-class types in Go.</li>
<li><a href="golang-container-types">container types</a>
	<ul>
	<li>array types - fixed-length container types.</li>
	<li>slice type - slcies can be viewed as dynamic arrays.</li>
	<li>map types - maps are associative arrays (or dictionaries). The official Go compiler implements maps as hashtables.</li>
	</ul>
</li>
<li>channel types - channels are used to synchronize data among goroutines (the green threads in Go).</li>
<li><a href="golang-interface">interface types</a> - interfaces play a key role in reflection and polymorphism.</li>
</ul>
</div>

<div>
Here are some literal representation examples of composite types:
<pre class="line-numbers"><code class="language-go">// Assume T is an arbitrary type and Tkey is
// a type supporting comparison (== and !=).

*T         // a pointer type
[5]T       // an array type
[]T        // a slice type
map[Tkey]T // a map type

// a struct type
struct {
	name string
	age  int
}

// a function type
func(int) (bool, string)

// an interface type
interface {
	Method0(string) int
	Method1() (int, bool)
}

// some channel types
chan T
chan<- T
<-chan T
</code></pre>
</div>

<h3>Fact: Kinds Of Types</h3>

<p>
Each of above mentioned basic and composite types corresponds
one kind of type. Besides these type kinds,
the type <code>unsafe.Pointer</code> introduced in the <code>unsafe</code>
standard package is also one kind of type in Go.
</p>

<p>
So, up to now (Go 1.9), Go has 26 kinds of types.
</p>

<p class="anchor" id="named-type"></p>
<h3>Concept: Named Types vs. Unnamed Types</h3>

<div>
In Go, 
<ul>
<li>
	if a type has a name, which must be an identifier, and its name is not
	the blank identifier <code>_</code>, then this type is called a named type.
	All built-in basic types are named types.</li>
</li>
<li>
	if a type can't be represented by a pure identifier,
	then the type is an unnamed type.
	The composite types listed in the above example are all unnamed types.
</li>
</ul>

<p>
An unnamed type must be a composite type,
It is not true vice versa, for composite types may be named types
(see type definition below).
</p>
</div>

<p>
The concepts of named and unnamed types play an important role in Go.
</p>

<h3>Syntax: Type Definitions</h3>

<p><i>
(<b>Type definition</b> is called <b>type declaration</b> before Go 1.9.
Since G0 1.9, type definition is one kind of type declartions.)
</i></p>

<div>
In Go, we can define new types by using the following syntax.
In the following example, <code>type</code> is a keyword.
<pre class="line-numbers"><code class="language-go">// define a solo new type.
type NewTypeName SourceType

// Define multiple new types together.
type (
	NewTypeName1 SourceType1
	NewTypeName2 SourceType2
)
</code></pre>
<p>
New type names must be identifiers, 
so a new defined type must be a named type,
except the new type name is the blank identifier <code>_</code>.
</p>

<div>
Note,
<ul>
<li>
	the new defined type and the source type in a type definition
	are two distinct types.
</li>
<li>
	two defined named types are always two distinct types. 
</li>
</ul>
</div>

<!---
Go spec 1.9 call above syntax as type definitions.
-->

<!---
Type definition can be viewed as type copying.
<ul>
<li>
	The new type will copy the value memory layout of the source type.
</li>
<li>
	If the source type is an interface type,
	the new type, also an interface type, will have the same method set as the source type.
</li>
<li>
	If the source type is a struct type,
	the new type will also copy all the fields of the source type.
</li>
<li>
	If the source type is a stuct type,
	then the new type will obtain the methods defined, either explictily or implicitly,
	for the types embedded in the source struct type.
</li>
<li>
	The new type will not obtain the methods directly defined for the source type.
</li>
</ul>

<p>
The new defined type and the source type are two different types,
even if their values share the same memory layout.
In other words, the new defined type is not an alias of the source type.
</p>

-->

Some type definition examples:
<pre class="line-numbers"><code class="language-go">// Both the new and source types in the following definition. 
// are named types.
type (
	MyInt int
	Age   int
	Text  string
)

// Following new defined and source types are all composite types.
// The new defined ones are all name types.
// The source ones are all unnamed types.
type IntPtr *int
type Book struct{author, title string; pages int}
type Convert func(in0 int, in1 bool)(out0 int, out1 error)
type StringArray [5]string
type StringSlice []string
type PersonAge map[string]int
type MessageQueue chan string
type Reader interface{Read([]byte) int}
</code></pre>
</div>

<p class="anchor" id="type-alias"></p>
<h3>Syntax: Type Alias Declarations</h3>

<p><i>
(<b>Type alias declaration</b> is one new kind of type declartions added since Go 1.9.)
</i></p>

<p>
As above mentioned, there are only two built-in type aliases in Go,
<code>byte</code> (alias of <code>uint8</code>) and
<code>rune</code> (alias of <code>int32</code>).
They are the only two type aliases before Go 1.9.
</p>

<div>
Since Go 1.9, we can declare custom type alias by using the following syntax:
<pre class="line-numbers"><code class="language-go">// declar a solo type alias
type Ta = []int

// Declare multiple type aliases together.
type (
	Tb = []int
	Tc = int
)
</code></pre>
<p>
Type alias names must be identifers.
</p>

<p>
The syntax of alias declaration is much like type definition,
but please note there is a <code>=</code> in the declaration.
</p>

<p>
By the above declarations, <code>Ta</code> and <code>Tb</code> are both
aliases of type <code>[]int</code>. 
In other words, they and <code>[]int</code> denote the same identical type.
Same as <code>[]int</code>, <b>they are both unnamed types</b>,
even if they look like named types.
</p>

<p>
Type alias declarations are much useful in refactoring large Go projects.
They are not recommended to be used in general programming.
</p>
</div>

<p class="anchor" id="underlying-type"></p>
<h3>Concept: Underlying Types</h3>

<div>
In Go, each type has an underlying type. Rules:
<ul>
<li>for built-in basic types, the underlying types are themselves.</li>
<li>the underlying type of <code>unafe.Pointer</code> is itself.</li>
<li>the underlying types of an unnamed type, which must be a composite type, is itself.</li>
<li>in a type definition, the new defined type and the source type have the same underlying type.</li>
</ul>

Examples:
<pre class="line-numbers"><code class="language-go">// The underlying types of the following ones are all int.
type (
	MyInt int
	Age   MyInt // for the underlying type of MyInt is int, 
	            // the underlying type of Age is also int.
)

// The following new types have different underlying types.
type (
	IntSlice   []int   // underlying type is []int
	MyIntSlice []MyInt // underlying type is []MyInt
	AgeSlice   []Age   // underlying type is []Age
)

// The underlying types of Ages and AgeSlice are both []Age.
type Ages AgeSlice
</code></pre>

How to trace to the underlying type for a given user defined type? 
The rule is when a built-in basic type, <code>unafe.Pointer</code> or an unnamed type is met, 
the tracing will be stopped.
Take the declarations above for example:
<pre>
MyInt → int
Age → MyInt → int
IntSlice → []int
MyIntSlice → []MyInt <span style="color:#aaa">→ <strike>[]int</strike></span>
AgeSlice → []Age <span style="color:#aaa">→ <strike>[]MyInt</strike></span> <span style="color:#aaa">→ <strike>[]int</strike></span>
Ages → AgeSlice → []Age <span style="color:#aaa">→ <strike>[]MyInt</strike></span> <span style="color:#aaa">→ <strike>[]int</strike></span>
</pre>

In Go,
<ul>
<li>types whose underlying types are <code>bool</code> are called <b>boolean types</b></a>;</li>
<li>types whose underlying types are any of <code>int8</code>, <code>uint8</code> (<code>byte</code>), <code>int16</code>, <code>uint16</code>, 
	<code>int32</code> (<code>rune</code>), <code>uint32</code>, <code>int64</code>, <code>uint64</code>, <code>uint</code>, <code>uint</code> 
	or <code>uinptr</code> are called <b>integer types</b></a>;</li>
<li>types whose underlying types are either <code>float32</code> or <code>float64</code> are called <b>floating-point types</b></a>;</li>
<li>types whose underlying types are either <code>complex64</code> or <code>complex128</code> are called <b>complex types</b></a>;</li>
<li>integer, floating-point and complex types are also called <b>numeric types</b></a>;</li>
<li>types whose underlying types are <code>string</code> are called <b>string types</b></a>.</li>
</ul>
</div>

<p>
The concept of underlying type plays an important role in
<a href="golang-conversions-assignments-and-comparisons">value vonversions, assignments and comparisions in Go</a>.
</p>

<h3>Concept: Values</h3>

<p>
An instance of a type is called a value, of the type. 
</p>

<p>
In terms of whether or not a value will resident in memory at run time,
values can be devided into two categories,
coding-time values and run-time values.
Coding-time values are for good code readibility purepose.
They will not stay in memory at run time, so they can't be taken addresses.
On the contrary, each run-time value is located at somewhere in memory at run time.
Although all run-time values have addresses,
for all kinds of reasons,
some of them can't be taken addresses at run time in Go.
</p>

<p>
If the types of two run-time values have the same underlying type,
then the memory layouts of the two values must be the same.
So the two values can be converted to the type of each other.
</p>

<h3>Concept: Value Sizes</h3>

<p>
The size of a value means how many bytes the value will be occupied
when the value is stored in memory.
</p>

<p>
The numbers in a numeric type name mean how many bits each value of this type will occupy.
Each byte is composed of 8 bits.
For example, each value of type <code>uint8</code> or <code>int8</code> will occupy 8 bits,
a.k.a., one byte.
So an <code>uint8</code> value can represent any integer in the range of [0, 255],
and an <code>uint8</code> value can represent any integer in the range of [-128, 127].
</p>

<p>
The value size of <code>uinptr</code> types must be large enough to
hold all the information of any pointer value.
</p>

<p>
Except <code>uinptr</code> type and the numeric types whose names indicate their value sizes,
Go official documentations don't specify the sizes of the other types.
The sizes of the other types are compiler and architecture dependent.
</p>

<h3>Concept: Literal Values</h3>

<div>
<p>
The text representation of a value is called the literal of the value.
The literal itself can be viewed as a value.
Literal values are all coding-time values.
</p>

The literal formats for different types are defined well in Go spec:
<ul>
<li><a href="https://golang.org/ref/spec#int_lit">integer literals</a>;</li>
<li><a href="https://golang.org/ref/spec#float_lit">floating-point literals</a>;</li>
<li><a href="https://golang.org/ref/spec#imaginary_lit">imaginary literals</a>;</li>
<li><a href="https://golang.org/ref/spec#rune_lit">rune literals</a>;</li>
<li><a href="https://golang.org/ref/spec#string_lit">string literals</a>;</li>
<li><a href="https://golang.org/ref/spec#CompositeLit">composite literals</a>;</li>
<li><a href="https://golang.org/ref/spec#FunctionLit">function literal</a>.</li>
</ul>

<p>
Integer, floating-point, imaginary and rune literals are also called numeric literals.
</p>

<p>
There are no pointer, channel and interface literals.
</p>

<p>
The two predeclared constant identifiers <code>true</code> or <code>false</code>
can be viewed as boolean literals.
</p>


<p>
The predeclared variable identifier <code>nil</code> can be viewed as special literal.
It will be called nil literal later.
</p>

Here a list of value literals.
It is not a complete list all kinds of literals.
Only the common used ones are listed.
Please check the above links for more literal forms.
<pre class="line-numbers"><code class="language-go">// bool literals
false
true

// integer literals
123  // decimal
0123 // octal
0xff // hex

// floating-point literals
0.0
.23
1.
1e-2 // 0.01

// string literals. The following two are equivalent.
// The second one crosses two lines.
"line1.\n\"line2\""
`line1.
"line2"`

// rune literals
'a'
'\n'
'\''
'\u68EE'

// array composite literals
[3]int{5, 6, 7}
[...]int{5, 6 ,7}
[3]int{2: 7, 0: 5, 1: 6}

// slice composite literals
[]string{"hello", "world"}
[]string{1: "world", 0: "hello"}

// map composite literals
map[string]int{"boys": 12, "girls": 11}

// struct composite literals
struct{a int}{123}
struct{a int}{a: 123}

// function literals
func(in0 string)(out0 int) {
	out0 = len(in0)
	return 
}

// the nil literal
nil
</code></pre>

Note,
<ul>
<li>
	there are two styles of string literals.
	One style is the string content is enclosed in a pair of <code>"</code> (double quote),
	such string literals are called interpreted string literals.
	The other style is the string content is enclosed in a pair of <code>`</code> (back quote),
	such string literals are called raw string literals.
	Interpreted string literals can't cross multiple lines.
	<a href="https://golang.org/ref/spec#Rune_literals">Some charater sequences starting with
	<code>\</code></a> will be escaped into one letter in interpreted string literals.
</li>
<li>
	a rune can be represented is a Unicode code point.
	As above has mentioned, <code>rune</code> is an alias of <code>int32</code> type.
</li>
<li>
	the <code>\n</code> in the above double-quote style string literals and rune literals
	will be escaped into a newline charactor which ASCII code is <code>10</code>.
</li>
</ul>
</div>

<h3>Concept: Zero Values</h3>

<p>
The default value of a type is called the zero value of the type.
Generally, a zero value stored in memory is totally composed of zero bytes.
But there are exceptions, depending on compilers and architectures.
</p>

<p>
The zero values of boolean types can be represented with <code>false</code> literally.
The zero values of numbric types can be represented with <code>0</code> literally.
</p>

<p>
The <code>nil</code> literal can used to represent zero values of
slice, map, function, channel, pointer and interface types.
</p>

<p>
About more on <code>nil</code>, please read <a href="golang-nil">nil in Go</a>.
</p>

<h3>Concept: Typed And Untyped Values</h3>

<p>
In Go, by whether or not a value has a deterministic type,
values can be categoried as two kinds, typed ones and untyped ones,
A typed value means the value has a deterministic typem
and an untyped value means the value has not a deterministic type.
</p>

<p>
All composite and function literals are typed values.
The type of such a literal is represented with the form by omitting
the final <code>{}</code> part from the literal.
For example, the type of <code>struct{a int}{a: 123}</code>
is <code>struct{a int}</code>, and the type of <code>[]string{"hello", "world"}</code>
is <Code>[]string</Code>.
</p>

<div>
Boolean, numeric or string literals are all untyped values.
Each of such literals has a default type and several potential types.
For example:
<ul>
<li>
	the default type of the literal <code>true</code> is the built-in <code>bool</code> type.
	but potentially, its type can also be any custom declared boolean types.
</li>
<li>
	the default type of <code>123</code> is the built-in <code>int</code> type,
	but potentially, its type can also be other built-in numeric types,
	such as <code>float64</code> and <code>int8</code>,
	or any custom declared numeric types.
</li>
<li>
	the default type of the literal <code>"abc"</code> is the built-in <code>string</code> type.
	but potentially, its type can also be any custom declared string types.
</li>
</ul>

<p>
The default type of a literal value is also one of its potential type.
</p>
</div>

<p>
Each nil literal is an untyped value.
It has many potential types,
including any slice, map, channel, function, pointer and interface types,
but it has not a default type.
</p>

<h3>Concept: Variables</h3>

<p>
Variable values are run-time values identified by 
<a href="https://golang.org/ref/spec#Identifiers">identifiers</a>.
Each variable must be given a type, either explicitly or implicitly, when it is declared.
So variables are all typed values.
</p>

<p>
Some articles treat all values which have addresses as variables, such as slice elements.
Go 101 articles don't adopt this definition.
In Go 101 articles, a variable must be declared and have a name.
</p>

<p>
About variable declaration,
please read <a href="golang-variable-and-constant-declaration#variable">this article</a>.
</p>

<h3>Concept: Constants</h3>

<p>
In Go, constants are identifiers each of which denotes
a boolean, numeric or string literal.
So constants are coding-time values and not addressable.
They will be replaced with the literals they denote at compile time.
</p>

<p>
Constants can be either typed or untyped.
</p>

<p>
About constant declarations,
please read <a href="golang-variable-and-constant-declaration#constant">this article</a>.
</p>

<h3>Concept: Dynamic Type And Dynamic Value Of An Interface Value</h3>

<p>
Interface values are the values whose types are interface types. 
</p> 

<p>
Each interface value can box a non-interface value in it.
The value boxed in an interface value is called the dynamic value of the interface value.
The type of the dynamic value is called the dynamic type of the interface value.
</p>

<p>
About interface types and values, please read
<a href="golang-interface">this article</a> for detail.
</p>

<h3>Concept: Signature Of Function Types</h3>

<p>
The signature of a function type is composed of 
the input parameter definition list and 
the output result definition list of the function.
</p>

<p>
The function name is not a part of a function signature.
Parameter and result types are important for a function signature,
but parameter and result names are not important.
</p>

<div>
Two unnamed function types with the same signature are the identical type.
For example, the following two function types are identical.
<pre class="line-numbers"><code class="language-go">func (a int, b []string) bool
func (int, []string) (result bool)
</code></pre>
</div>

<p>
About function types and values,
please read <a href="golang-function">this article</a> for detail.
</p>

<h3>Concept: Method And Method Set Of A Type</h3>

<p>
In Go, some types can have <a href="golang-method">methods</a>.
Methods can also be called member functions.
</p>

<p>
The methed set of a type is composed of all the methods of the type.
If the method set of a type is the super set of the method set
of an interface type, we say the type
<a href="golang-interface#implementation">implements</a> the interface type.
</p>

<p>
Two unnamed interface types with the same method set are the same type.
</p>

<h3>Concept: Fields Of A Struct Type</h3>

<div>
A struct type is composed of a collection of member variables.
Each of the member variables is called a field of the struct type.
For example, the following struct type <code>Book</code> has
three fields, <code>author</code>, <code>title</code> and <code>pages</code>.
<pre class="line-numbers"><code class="language-go">struct {
	author string
	title  string
	pages  int
}
</code></pre>
</div>

<p>
About struct types and values,
please read <a href="golang-struct">this article</a> for detail.
</p>

<p>
In Go, we can extend a type which satisfies some conditions by
<a href="golang-type-embedding">embedding</a> this type in a struct type.
</p>

<p class="anchor" id="pointer-base-type"></p>
<h3>Concept: Base Type Of A Pointer Type</h3>

<p>
For a pointer type, assume its underlying type can be denoted as <code>*T</code> literally,
then <code>T</code> is called the base type of the pointer type.
</p>

<p>
Two unnamed pointer types with identical base types are the identical type.
</p>

<p>
About pointer types and values, please read <a href="golang-pointer">this article</a> for detail.
</p>

<h3>Concept: Container Types</h3>

<p>
Array, slice and map can be viewed as formal built-in container types.
</p>

<p>
Informally, string and channel types can also be viewed as container types.
</p>

<p>
Each value of a container type has a length,
either the container type is a formal one or an informal one.
</p>

<p>
About container types and values,
please read <a href="golang-container-types">this article</a> for detail.
</p>

<h3>Concept: Key Type And Element Type Of A Container Type</h3>

<div>
Element types of different container type:
<ul>
<li>for an array type, if its underlying type is <code>[N]T</code>, then its element type is <code>T</code>.</li>
<li>for a slice type, if its underlying type is <code>[]T</code>, then its element type is <code>T</code>.</li>
<li>for a map type, if its underlying type is <code>map[Tkey]T</code>, then its element type is <code>T</code>.</li>
<li>for a channel type, if its underlying type is <code>chan T</code>, <code>chan&lt;- T</code> or <code>&lt;-chan T</code>, then its element type is <code>T</code>.</li>
<li>the element type of a string type is always <code>byte</code> (a.k.a. <code>uint8</code>).</li>
</ul>
</div>

<div>
Key types of different container type:
<ul>
<li>for a map type, if its underlying type is <code>map[Tkey]T</code>, then its key type is <code>Tkey</code>.</li>
<li>the key types of array, slice and string types are all <code>int</code>.</li>
<li>channel types have no key types.</li>
</ul>
</div>

<p>
Two unnamed array types with identical element types and the same length are the identical type.
</p>

<p>
Two unnamed slice types with identical element types are the identical type.
</p>

<p>
Two unnamed map types with identical key and element types are the identical type.
</p>

<!---
<p>
The keys and elements of a container value can be iterated
with the for-range syntax.
But please note: in for-range loops,
the iterated element values are runes, instead of bytes.
</p>
-->

<h3>Concept: Directions Of Channel Types</h3>

<div>
Channel values can be viewed as synchronized first-in-first-out (FIFO) queues.
Channel types and values have directions.
<ul>
<li>
	The channels we can both send other values to and receive values from
	are called bidirectional channels.
	Bidirectional channels are denoted as <code>chan T</code> literally.
</li>
<li>
	The channels we can only send other values to
	are called send-only channels.
	Send-only channels are denoted as <code>chan<- T</code> literally.
</li>
<li>
	The channels we can only receive values from
	are called receive-only channels.
	Receive-only channels are denoted as <code><-chan T</code> literally.
</li>
</ul>
</div>

<p>
Two unnamed channel types with identical element types and the same direction are the identical type.
</p>

<p>
About channel types and values,
please read <a href="golang-channel">this article</a> for detail.
</p>

<p class="anchor" id="types-not-support-comparison"></p>
<h3>Fact: Types Which Support Or Don't Support Comparison</h3>

<div>
Currently (Go 1.9), following types don't support comparison
(equality comparison):
<ul> 
<li>slice types</li>
<li>map types</li>
<li>function types</li>
<li>
any struct type with a field whose type is incomparable
and any array type which element type is incomparable.
</li>
</ul>

<p>
About the detailed rules of comparisons, please read
<a href="golang-conversions-assignments-and-comparisons#comparison-rules">this article</a>.
</p>
</div>

<p>
The key type of any map type must be a comparable type.
So the above listed types can't be used as map key types.
</p>

<h3>Fact: Generic In Go</h3>

<div>
We can use composite types to composite different types.
Here are some examples:
<pre class="line-numbers"><code class="language-go">// This is a slice type, whose element type is map type map[string]int.
[]map[string]int

// This is a pointer type, whose base type is a channel type.
// The element type of the channel type is a slice type []int.
*chan []int

// This is a map type, whose key type is an array type [16]byte.
// The element type of the map type is a pointer type "*[256]func() int".
// The base type of the pointer type is an array type "[256]func() int".
// The element type of the array type is a function type "func() int".
map[[16]byte]*[256]func() int
</code></pre>
</div>

<p>
The generic functionalities supported in Go are limited now.
Up to now (v1.9), Go doesn't support generic for custom types and custom functions.
Although generic is not essential for programming,
sometimes it is really a pain by lacking of it.
Go language development team
<a href="https://research.swtch.com/go2017#generics">wouldn't mind supporting generic feature in Go</a>,
it is just that they <a href="https://github.com/golang/go/issues/15292">haven't found a generic solution</a>
which will keep Go simple and clean yet.
</p>



