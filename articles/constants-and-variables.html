<h1>Constants And Variables</h1>

<p>
This article will introduce constant and variable declarations in Go.
The concept of untyped values will also be introduced.
</p>

<p class="anchor" id="untyped-value"></p>
<h3>Untyped Values And Typed Values</h3>

<p>
In Go, some values are untyped.
An untyped value means the type of the value has not been confirmed yet.
Each untyped value has several potential types.
On the contrary, the type of a typed value is determined.
</p>

<p>
For most untyped values, each of them has one default type.
The default type of an untyped value is one potential type of the untyped value.
(The predeclared <code>nil</code> is the only untyped value
which has not a default type.
We can learn more about <code>nil</code> in other Go 101 articles later.)
</p>

<p>
The value literals (also called literal constants) of basic types introduced in
the last article, <a href="basic-types-and-value-literals.html">basic types
and their value literals</a>, are all untyped values.
</p>

<p>
And the potential types of a literal constant are determined
by values of which types the literal can represent.
The default type of a literal constant is determined by its literal form.
The default types of boolean literals are <code>bool</code>.
The default types of floating-point literals are <code>float64</code>.
The default types of integer literals are <code>int</code>.
The default types of rune literals are <code>rune</code> (a.k.a, <code>int32</code>).
The default types of string literals are <code>string</code>.
If a literal contains an imaginary part,
then its default type is <code>complex128</code>.
</p>

<p>
The following table lists the default types and popential types of some
untyped literal constants.
</p>

<table class="table table-bordered text-center" style="width: auto !important;">
<thead>
	<tr class="active">
	<th class="text-center" style="white-space: nowrap;">Untyped Value</th>
	<th class="text-center" style="white-space: nowrap;">Default Type</th>
	<th class="text-center" style="white-space: nowrap;">Potential Types</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center"><code>true</code></td>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			<code>bool</code>
		</td>
		<td style="vertical-align: middle;" class="text-left">
			<code>bool</code> and other custom defined boolean types.
		</td>
	</tr>
	<tr>
		<td scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center"><code>256</code></td>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center" rowspan="3">
			<code>int</code>
		</td>
		<td style="vertical-align: middle;" class="text-left">
			All numeric types except the ones belong to the kinds of <code>int8</code> and <code>uint8</code>.
		</td>
	</tr>
	<tr>
		<td scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center"><code>-123</code></td>
		<td style="vertical-align: middle;" class="text-left">
			All numeric types except the unsigned ones.
		</td>
	</tr>
	<tr>
		<td scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center"><code>123</code></td>
		<td style="vertical-align: middle;" class="text-left" rowspan="5">
			All basic numeric types, either built-in ones and custom declared ones.
		</td>
	</tr>
	<tr>
		<td scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center"><code>123.</code></td>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center" rowspan="2">
			<code>float64</code>
		</td>
	</tr>
	<tr>
		<td scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center"><code>1e2</code></td>
	</tr>
	<tr>
		<td scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center"><code>'a'</code></td>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			<code>rune</code> (<code>int32</code>)
		</td>
	</tr>
	<tr>
		<td scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center"><code>1.0+0i</code></td>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center" rowspan="2">
			<code>complex128</code>
		</td>
	</tr>
	<tr>
		<td scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center"><code>1+2i</code></td>
		<td style="vertical-align: middle;" class="text-left">
			<code>complex128</code>, <code>complex64</code> and other custom defined complex types.
		</td>
	</tr>
	<tr>
		<td scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center"><code>1.23</code></td>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			<code>float64</code>
		</td>
		<td style="vertical-align: middle;" class="text-left">
			<code>float64</code>, <code>float32</code> and other custom defined floating-point types.
		</td>
	</tr>
	<tr>
		<td scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center"><code>"abc"</code></td>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			<code>string</code>
		</td>
		<td style="vertical-align: middle;" class="text-left">
			<code>string</code> and other custom defined string types.
		</td>
	</tr>
</tbody>
</table>

<p class="anchor" id="type-deduce"></p>
<h3>Type Deduction In Go</h3>

<p>
Go supports type deduction. In other words, in many scenarios, programmers
don't need to explicitly speficify the types of some values in code.
Go compilers will deduce the types for these values by context.
</p>

<p>
In Go code, if a place needs a value of a certain type and the certain type
is one of the potential types of an untyped value, then the untyped value
can be used in the place.
Go compilers will view the untyped value as a typed value of the certain type.
Such places include an operand in an operator operation, an argument in
a function call, a destination value or a source value in an assignment, etc.
</p>

<p>
Some scenarios have no requirements on the types of the used values.
If an untyped value is used in such a scenario, Go compilers will
treat the untyped value as a typed value of its default type.
</p>

<p>
The below variable section will show some type deduction cases.
More type deduction rules and cases will be introduced in
<a href="conversions-operators-and-functions.html">operators and functions</a>
and other articles.
</p>

<p class="anchor" id="constant"></p>
<h3>Constant Declarations</h3>

<div>
<p>
The literals introduced in <a href="basic-types-and-value-literals.html">the
last article</a> are all called unnamed constants,
except <code>false</code> and <code>true</code>,
which are two predeclared (built-in) named constants.
This section will introduce how to declared custom named constants.
</p>

Like unnamed constants, named constants can also only be
boolean, numeric and string values.
The keyword <code>const</code> is used to declare constants.
The following program contains some type declarations.

<pre class="line-numbers"><code class="language-go">package main

// Declare a single constant.
// Yes, non-ASCII letter can be used in identifiers.
const π = 3.1416
const Pi = π // equivalent to: Pi == 3.1416

// Declare multiple constants as a group by using ().
const (
	No         = !Yes
	Yes        = true
	MaxDegrees = 360
	Unit       = "radian"
)

func main() {
	// Declare multiple constants in one code line.
	const DoublePi, HalfPi, Unit2 = π * 2, π * 0.5, "degree"
}
</code></pre>

<p>
In the above example,
the <code>*</code> symbol is the multiplication operator
and the <code>!</code> symbol is the boolean-not operator.
Operators will be introduced in the next article,
<a href="conversions-operators-and-functions.html">operators and functions</a>.
</p>

<p>
The <code>=</code> symbol should be viewed as "bind" instead of "assign".
Constant declarations bind the declared named constants
to the corresponding literals.
In the above example, the name constants <code>π</code> and <code>Pi</code>
are both bound to the literal <code>3.1416</code>.
The two named constants may be used at many places in code.
Without constant declarations, the literal <code>3.1416</code> would be
populated at those places. If we want to change the literal
to <code>3.14</code> later, many places need to be modified.
With the help of constant declarations, the literal <code>3.1416</code>
will only appear in one constant declaration,
so only one place need to be modified.
This is the main purpose of constant declarations.
</p>

<p>
Please note that, constants can be declared both
at package level (out of any function body) and in function bodies.
The constants declared in function bodies are called local constants.
The variables declared out of any function body
are called package-level constants.
We also often call package-level constants as global constants.
Exported package-level constants can be used in other packages
if the package
</p>

<p>
The declaration orders of two package-level constants are not important.
In the above example, the declaration orders of
<code>No</code> and <Code>Yes</code> can be exchanged.
</p>

All constants decalred in the last example are untyped.
We can delcared typed constants.
In the following example, all the four declared constants are typed values.
The types of <code>X</code> and <code>Y</code> are both <code>float32</code>
and the types of <code>A</code> and <code>B</code> are both <code>int64</code>.

<pre class="line-numbers"><code class="language-go">const X float32 = 3.14

const (
	A, B int64   = -3, 5
	Y    float32 = 2.718
)
</code></pre>

<p>
Go specification calls each of the lines in
the above constant declaration group as a <b><i>constant specification</i></b>.
In the following part of this section,
a constant specification will be called a <b><i>logic code line</i></b>.
</p>

<p>
If multiple typed constants are declared in the same one logic code line,
then their types must be the same, just as the constants
<code>A</code> and <code>B</code> in the above example.
</p>

In a group-style constant declaration, except the first logic line,
other logic lines can be incomplete.
Compilers will autocomplete the incomplete lines for us by
copying the missing part from the first preceding complete logic line.
For example, at compile time, compilers will automatically
complete the following code

<pre class="line-numbers"><code class="language-go">const (
	X float32 = 3.14
	Y                // here must be one identifier
	Z                // here must be one identifier
	
	A, B = "Go", "language"
	C, _                   // here must be two identifier
)
</code></pre>

as

<pre class="line-numbers"><code class="language-go">const (
	X float32 = 3.14
	Y float32 = 3.14
	Z float32 = 3.14
	
	A, B = "Go", "language"
	C, _ = "Go", "language"
)
</code></pre>

<p>
Here, the blank identifier <code>_</code> is to ignore,
but can't be omitted, the last declared constant.
</p>

The autocomplete feature plus the <code>iota</code> constant generator
feature brings much convenience to Go programming.
<code>iota</code> is a predeclared constant. It is declared as
<pre class="line-numbers"><code class="language-go">const iota = 0
</code></pre>

<p>
But the value of an <code>iota</code> in code may be not always <code>0</code>.
When the predeclared <code>iota</code> constant is used in
a custom constant declaration, at compile time,
within the custom constant declaration,
its value will be reset to <code>0</code> at the first logic line
and will increase <code>1</code> logic line by logic line.
So <code>iota</code> is only useful in group-style constant declarations.
</p>

Here is an example using both the autocomplete
and the <code>iota</code> constant generator features.
Please read the comments to get what will happen at compile time.
The <code>+</code> symbol in this example is the addition operator.

<pre class="line-numbers"><code class="language-go">package main

func main() {
	const (
		k = 3 // now, iota == 0
		
		m float32 = iota + 0.1 // m float32 = 1 + 0.1
		n                      // n float32 = 2 + 0.1
		
		p = 9             // now, iota == 3
		q = iota * 2      // q = 4 * 2
		_                 // _ = 5 * 2
		r                 // r = 6 * 2
		s, t = iota, iota // s, t = 7, 7
		u, v              // u, v = 8, 8
		_, w              // _, w = 9, 9
	)
	
	const x = iota // x = 0
	const (
		y = iota // y = 0
		z        // z = 1
	)
	
	println(m, n)          // +1.100000e+000 +2.100000e+000
	println(q, r)          // 8 12
	println(s, t, u, v, w) // 7 7 8 8 9
	println(x, y, z)       // 0 0 1
}
</code></pre>

The above example is just to demo the rules of
the <code>iota</code> constant generator feature.
Surely, in practice, we should use it in more meaningful ways.
For example, 

<pre class="line-numbers"><code class="language-go">const (
	Failed = iota - 1 // == -1
	Unknown           // == 0
	Succeeded         // == 1
)

const (
	Readable = 1 << iota // == 1
	Writable             // == 2
	Executable           // == 4
)
</code></pre>

<p>
Here, the <code>-</code> symbol is the subtraction operator,
and the <code>&lt;&lt;</code> symbol is the left-shift operator.
Both of the two operators will be introudced in the next article.
</p>

</div>

<p class="anchor" id="variable"></p>
<h3>Variables, Variable Declarations And Value Assigments</h3>

<p>
Variables are named values.
Variables are stored in memory at run time.
The value represented by a variable can be modified at run time.
</p>

<p>
All variables are typed values.
When declaring a variable, there must be sufficient information provided
for compilers to deduce the type of the variable.
</p>

<p>
The variables declared in function bodies are called local variables.
The variables declared out of any function body
are called package-level variables.
We also often call package-level variables as global variables.
</p>

<div>
There are two basic variable declaration forms,
the standard one and the short one.
Please read the comments in the following program to learn
how to declare variables and do value assignments in Go programming.

<pre class="line-numbers"><code class="language-go">package main

func main() {
	// This is the full standard form of variable declaration.
	// A variable named "website" is declared and inialized.
	// Its type, string, is specified explicitly.
	// "var" is a keyword used to declare variables.
	var website string = "https://golang.org"
	
	// This is a variant of the standard form. In this form,
	// variable type is not specified. Compiler will deduce
	// its type as the default type of the literal "Go".
	// So the type of "name" is also string.
	var name = "Go"
	
	// This is another variant of the standard form. In this
	// form, the variable initial value is not specified.
	// Its initial value is the zero value of its type, "".
	var currentVersion string
	
	// Multiple variables can be decalred at the same line.
	// If no initial values are provided, they must share
	// the same type and their types must be specified.
	// Their initial values are the zero value of the
	// specified type, here the zero value is 0.
	var bornYear, bornMonth, bornDay int

	// If the types of the variables declared at the same
	// line are not all the same, then their types must not
	// be present in the declaration, but their initial values
	// must be all specified. Compilers will deduce their
	// types from the specified initial values. Here, the
	// types of the three variables are int, bool, bool.
	var announceYear, static, compiled = 2009, true, true
	
	/*
	In the above standard variable declarations, all variables
	at the left of the assignment sign "=" must be new ones.
	*/
	
	// This is a pure assignment. Multiple values can be modified
	// at the same code line. All variables at the left of the
	// assignment sign "=" in an assignment must be ever declared.
	bornYear, bornMonth, bornDay = 2007, 11, 10

	// We can exchange the two variables values in one line.
	static, compiled = compiled, static
	
	/*
	The following is a short variable declaration form.

	In a short delcaration form, the "var" keyword and
	variable types must be omitted. And the assignment sign
	must be ":=" instead of "=".

	In a short variable delcaration, old variables and new
	variables can mix at the left of ":=". But there must be
	at least one new variable at the left.
	
	In the following short variable declaration, the "name"
	variable is an old variable which has been declared earlier
	and the "numKeywords" variable is a new one. So here the
	"name" variable is modified by an assignment but the
	"numKeywords" variable is declared and initialized.
	*/
	name, numKeywords := "Go", 25
	
	// Use some of the declared variables above.
	println(name, "was born at year", bornYear)
	println(name, "was announced at year", announceYear)
	// releaseAt is a package-level variable declared below.
	println(name, "1.0 was released at year",  releaseAt)
	
	// In Go, local declared variables must be used,
	// otherwise, compiler will report errors for
	// unused declared local variables.
	// We can assign the unused variables to the
	// blank identifier to make them used.
	_, _, _ = static, compiled, currentVersion
	_, _, _, _ = website, numKeywords, bornMonth, bornDay
}

// Above declared variables are called local variables, which
// are declared within function bodies.
// Variables can also be declared outside of any function bodies.
// Such variables are calld package-level variables.
// Package-level variables are often called global variables.

// Package-level variables must be declared with standard
// variable declaration forms. They can't be declared with
// the short variable declaration form.
var createdBy, releaseAt = "Google Research", 2012

// Unlike local variables, package-level variables can be
// decalred but never used. Here the "createdBy" variable
// is never used in the program. This is allowed.
</code></pre>

<p>
All the <code>=</code> symbols in the above example mean "assign".
</p>

The output of the above example:
<pre class="output">
Go was born at year 2007
Go was announced at year 2009
Go 1.0 was released at year 2012
</pre>

<p></p>

<p>
Please note, <b>in a short variable delcaration, all items at the left of the
<code>:=</code> sign must pure identifiers.</b>
This means some other assignable items,
which will be introduced in other articles,
can't appear at the left of <code>:=</code>.
These iteams include qualified identifiers, container elements,
pointer dereferences and struct field selectors.
</p>

<p>
As shown in the above example, the type deduction feature allows us
not to always specify the variable types in variable declarations.
This brings much convenience to Go programming
and makes Go code look very clean.
</p>

From the above explainations, we know that the following ways are equivalent
to declare a local <code>int</code> variable with initial value <code>0</code>.
The first three ones are equivalent to declare a global (package-level) variable.

<pre class="line-numbers"><code class="language-go">var a int = 0
var a int
var a = 0
a := 0
</code></pre>

Multiple variables can be grouped into one standard form declaration
by using <code>()</code>.
For example, the following variable declarations
<pre class="line-numbers"><code class="language-go">var a, b bool
var m int8 = 123
var x, y = 3.2, 5.6
</code></pre>

can be rewritten to
<pre class="line-numbers"><code class="language-go">var (
	a, b bool
	m    int8 = 123
	x, y      = 3.2, 5.6
)
</code></pre>

<p>
Generally, declaring related variables together will
make code get a better readability.
</p>

Constants can be assigned to variables, but not vice versa.

<pre class="line-numbers"><code class="language-go">const N = 100.0
const K int64 = N

var x = N   // the type of x is the default type of N, float64.
var y = K   // the type of y is the type of K, int64.
var z = 100 // the type of x is the default type of literal 100, int.
var w = y   // the type w is the same as y (int64).

// The following line fails to compile.
/*
const M = x
*/
</code></pre>

</div>

<h3>Resource Scopes</h3>

todo (cancelled): move type define and type alias ito basic ty

todo: move this section to package article.

Variable and named constant are two kinds of resources in Go.
Names of resources
Scopes

<p>
The scope (visibility range) of a package-level variable or constant identifer
is the whole package of the variable or named constante is declared in.
The scope of a local variable or constant identifer begins at the end of
its declaration and ends at the end of the innermost its containing block.
Code blocks and identifier scopes will be explained detailedly in
<a href="block-and-scope.html">blocks and scopes</a>.
</p>

<h3>Exported Resources vs. Non-Exported Resources</h3>

As Exported Constants And Variables

<p>
If the identifier of a package-level declared constant (or variable)
is exported, then the constant (or variable) is called exported constant
(or exported variable).
When the package is imported into other package source files,
the constant (or variable) is visible for those source files.
Package imports will be explained in
<a href="packages-and-imports.html">code packages and package imports</a>.
</p>

if exported, ...

<h3>More About Constant Declarations</h3>

todo: how to represent max value of an unsigned integer: ^T(0).

todo: untyped values can be very large.

<h3>More About Constant Declarations</h3>

<p>
Constant declarations can be viewed as enhanced macro defines in C.
A constant declaration define a named constant which represents a literal.
All the occurances of a named constant will be replaced with the literal
it represents at compile time.
</p>

<p>
If the two operands of an operator operation are both constants,
then the opeartion will be evaluated at compile time.
(Please read the next article
<a href="conversions-operators-and-functions.html">operators and functions</a> for details.)
</p>

For example, at compile time, the follow code

<pre class="line-numbers"><code class="language-go">package main

const X = 3
const Y = X - 1
var a = X + X

func main() {
	b := Y + Y
	println(a, b, X, Y)
}
</code></pre>

will be tranlated to

<pre class="line-numbers"><code class="language-go">package main

var a = 6

func main() {
	b := 4
	println(a, b, 3, 2)
}
</code></pre>

<h3>Value Addressability</h3>

<p>
In Go, some values are addressable.
Addressable values can be taken addresses.
All variables are addressable and all constants are unaddressable.
We can learn more about addresses and pointers from the article
<a href="pointer.html">pointers in Go</a>
and learn other adressable and unadressable values from other articles later.
</p>



