<h1>Deferred Function Calls And Goroutines</h1>

<p>
This article will introduce goroutines and deferred function calls.
Goroutine and deferred function call are two unique features in Go.
As the two features share several knowledgements, they are explained
together in the current artile.
Not all knowledgements relating to the two features are convered in the
current article, other ones will be introduced in other articles later.
</p>

<h3>Deferred Function Calls</h3>

<p>
A deferred function call is a function call which follows a <code>defer</code> keyword.
All the result values of the function call (if the called function has return results)
must be discarded in the function call statement.
</p>

<p>
When a function call is deferred, it is not executed immediately.
It will be push into a defer-call stack maintained by its caller (another function call).
There may be multiple function calls deferred in its caller.
The deferred function called will be executed, by their inverse orders being
pushed into the defer-call stack, when the caller function call returns
and enters the exiting phase. 
</p>


<div>
Here is a simple example to show how to use deferred function calls.
In the example, <code>defer</code> are keywords.
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	defer fmt.Println("The third line.")
	defer fmt.Println("The second line.")
	fmt.Println("The first line.")
}
</code></pre>

The output:
<pre class="output"><code>The first line.
The second line.
The third line
</code></pre>

<p>
</p>

The following example fails to compile.

<pre class="line-numbers"><code class="language-go">package main

func f() int {
	return 123
}

func main() {
	defer x := f() // error: the result value is not disgarded.
	_ = x
}
</code></pre>

<p>
</p>

Here is another example which is a little more complex.
The example will print <code>0</code> to <code>9</code>,
each per line, by their natural order.
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	defer fmt.Println("9")
	fmt.Println("0")
	defer fmt.Println("8")
	fmt.Println("1")
	if false {
		defer fmt.Println("not reachable")
	}
	defer func() {
		defer fmt.Println("7")
		fmt.Println("3")
		defer func() {
			fmt.Println("5")
			fmt.Println("6")
		}()
		fmt.Println("4")
	}()
	fmt.Println("2")
	return
	defer fmt.Println("not reachable")
}
</code></pre>

<p>
</p>
</div>

<h3>Deferred Anonymous Functions Can Modify The Named Return Results Of Nesting Functions</h3>

<div>
For example,
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func Triple(n int) (r int) {
	defer func() {
		r += n // modify the return value
	}()
	
	return n + n // <=> r = n + n; return
}

func main() {
	fmt.Println(Triple(5)) // 15
}
</code></pre>
</div>

<h3>The Necessary And Benefits Of The Defered Function Feature</h3>

<p>
In the above examples, the deferred function calls are not absolutely necessary.
However, from the next article, we will learn that
the deferred function call feature is a necessary feature for the
<a href="panic-and-recover.html">panic and recover mechanism</a> in Go.
</p>

<p>
Deferred function calls can also help us write more clean and robust code.
We can read more code examples by using deferred functtion calls
and learn more details on deferred function cals in the article
<a href="defer-more.html">more about deferred functions</a> later.
</p>

<h3>Goroutines</h3>

<p>
Goroutines are also often called green threads.
Green threads are maintained and scheduled by language runtime instead of operation systems.
The cost, such as memory consumption and context switching,
of a goroutine is much smaller than an OS thread.
So it is not a problem for a Go program to maintain tons of thoundsands
goroutines at the same time, as long as the system memory is sufficient.
</p>

<p>
Go doesn't support creating system threads.
So using goroutines is the only way to do concurrent programing
(in one program) in Go.
</p>

<p>
Each Go program starts with only one goroutine,
the main goroutine, at the beginning.
A goroutine can create new goroutines.
It is super easy to create a new goroutine in Go,
just make a function call follow a <code>go</code> keyword,
then the function call will be executed in a new created goroutine.
The new created goroutine will exit alongside the exit of the function call.
</p>

<div>
Like deferred function calls, all the result values of a goroutine function call
(if the called function has return results), must be discarded in the function call statement.
The following is an example which creates two new goroutines in the main goroutine.
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	go fmt.Println("Hello")
	go fmt.Println("Goodbye")
}
</code></pre>

<p>
Quite easy. Right? Let's run it. It is very possible that the program outputs nothing.
Why? Because <b>a program will exit when the main goroutine has already exited</b>.
When the main goroutine exits, the two new created goroutines have not
got chances to print their respective texts.
</p>

The following is an imperfect fix for the above example.
<pre class="line-numbers"><code class="language-go">package main

import "fmt"
import "time"

func main() {
	go fmt.Println("Hello")
	go fmt.Println("Goodbye")
	time.Sleep(time.Second)
}
</code></pre>

<p>
Run the second version again. It is very possible that the two texts are both printed,
in their corresponding goroutine.
At a time in the program running, there may be three goroutines running at the same time.
We call this program as a concurrent program.
We are doing cuncurrent progrmaming now!
</p>

<p>
If we run the second version several times, we will find that
the output order of the two texts are not always the same.
Sometimes, <code>Hello</code> is printed before <code>Goodbye</code>,
sometimes, <code>Goodbye</code> is printed before <code>Hello</code>.
Altough the first new goroutine is created before the second one,
they are running at the same time once they are both created.
</p>

The following is another fix to make the text output orders consistent.
<pre class="line-numbers"><code class="language-go">package main

import "fmt"
import "time"

func main() {
	go func() {
		fmt.Println("Hello")
		go fmt.Println("Goodbye")
	}()
	time.Sleep(time.Second)
}
</code></pre>

<p>
In the third version, the second new goroutine is created in the first
new goroutine and after the <code>Hello</code> text has been printed.
So, the <code>Goodbye</code> text is printed after the <code>Hello</code> text
for sure, if they are both printed in the end.
</p>

<p>
The third version is still a bad concurrent program example.
We should not rely on the assumption that the two texts will
be printed in one second, and in any time duration, for sure.
If the program runs on a computor which CPUs are occupied by many other
programs running on the computer, the two goroutines may still not be
able to get chances to execute in a short period.
</p>

<p>
Then, how to make a perfect fix for the program?
We must use a concurrency synchronization technique to synchronize goroutines.
Go supports several concurrency synchronization techniques. The article
<a href="concurrent-synchronization-overview.html">concurrency synchronization overview</a>
will introduce them.
</p>

<p>
Among the concurrency synchronization techniques supported in Go,
channel is the most unique one.
Channel types are one kind of first-level citizen types in Go.
The current article will not provide a perfect fix the above program.
We can find a perfect fix in the article <a href="channel.html">channels in Go</a> later.
</p>

</div>

<h3>The Cost Of Goroutines</h3>

<p>
The cost of a new goroutine is very small in Go.
It is okay for a Go program to create thounsands of, even millions of,
concurrent goroutines, as long as there is enough memory.
</p>

<h3>The Evaluation Moment Of The Arguments Of Deferred And Goroutine Function Calls</h3>

<div>
The arguments of a deferred function call or a goroutine function call are all
evaluated at the moment when the function call is invoked.
<ul>
<li>
	For a deferred function call, the invocation moment is
	the moment when it is pushed into the defer-call stack of its caller.
</li>
<li>
	For a goroutine function call, the invocation moment is
	the moment when the corresponding goroutine is created.
</li>
</ul>

<p>
The arguments of each function call nested in a deferred function call
or a goroutine function call are evaluated at the moment when that nested
function call is are invoked.
</p>

Here is an example.
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	func() {
		for i := 0; i < 3; i++ {
			defer fmt.Println("a:", i)
		}
	}()
	fmt.Println()
	func() {
		for i := 0; i < 3; i++ {
			defer func() {
				fmt.Println("b:", i)
			}()
		}
	}()
}
</code></pre>

Run it. The output:
<pre class="output"><code>a: 2
a: 1
a: 0

b: 3
b: 3
b: 3
</code></pre>

<p>
The first loop prints <code>i</code> as <code>2</code>, <code>1</code> and <code>0</code> as a sequence.
The second loop always prints <code>i</code> as <code>3</code>,
for when the three <code>fmt.Println</code> calls in the deferred anonymous calls are invoked,
the value of the loop variable <code>i</code> has become to <code>3</code>.
</p>

The same argument valuation moment rules for goroutine function calls.
The following program will output <code>123 789</code>.

<pre class="line-numbers"><code class="language-go">package main

import "fmt"
import "time"

func main() {
	var a = 123
	go func(x int) {
		time.Sleep(time.Second)
		fmt.Println(x, a) // 123 789
	}(a)
	
	a = 789
	
	time.Sleep(2 * time.Second)
}
</code></pre>

<p>
Again, it is not a good idea to do synchronizations by using using
<code>time.Sleep</code> calls.
We should use the concurrency synchronization techniques introduced in the article
<a href="concurrent-synchronization-overview.html">concurrency synchronization overview</a>
to do synchronizations in formal projects.
</p>

</div>


