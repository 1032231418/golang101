<h1>Built-in Generic And Type Compositions</h1>

<p>
Go 1 doesn't support custom generic types and functions.
However, Go 1 supports generic for built-in functions and
some kinds of composite types, including
<a href="pointer.html">pointer types</a>,
<a href="channel.html">channel types</a>,
and <a href="container.html">container types</a>
(arrays, slices and maps).
We can use these types to composite many, infinite in theory,
types we needed in go programming.
</p>

<p>
Type compositions in Go are designed very intuitive and easy to interpret.
It is hardly to get lost on understanding Go composite types,
even if for some very complex ones.
</p>

<h3>Type Composition Examples</h3>

<p>
Let's check some examples, from simple ones to complex ones,
to learn how to interpret complex composite types in Go.
As just has mentioned, it is not hard.
</p>

<h4>Example 1</h4>

<div>

<pre class="line-numbers"><code class="language-go">[3][4]int
</code></pre>

<p>
When interpreting a composite type, we should look at it from left to right.
The <code>[3]</code> on the left indicates that this type is an array type.
The whole right part following the <code>[4]int</code> is another array type,
which is the element type of the first array type.
The first array type can be viewed as a two-dimention array type.
</p>

An example on using this two-dimention array type type.
<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
)

func main() {
	matrix := [3][4]int{
		{1, 0, 0, 1},
		{0, 1, 0, 1},
		{0, 0, 1, 1},
	}
	
	matrix[1][1] = 3
	a := matrix[1] // type of a is [4]int
	fmt.Println(a) // [0 3 0 1]
}
</code></pre>

</div>

<h4>Example 2</h4>

<div>

<pre class="line-numbers"><code class="language-go">**stuct{x bool}
</code></pre>

<p>
The left <code>*</code> sign on the left indicates that this type is a pointer type.
The whole right part <code>*stuct{x bool}</code> following the first <code>*</code>
sign denotes another pointer type, which is the element type
is a struct type <code>stuct{x bool}</code>.
The struct type has one field with <code>bool</code> type.
</p>

</div>

<h4>Example 3</h4>

<div>

<pre class="line-numbers"><code class="language-go">chan *[16]byte
</code></pre>

<p>
The <code>chan</code> keyword at the left most indicates this type is a channel type.
The whole right part <code>*[16]byte</code>, which is a pointer type,
denotes the element type of this channel type.
The base type if the pointer type is <code>[16]byte</code>, which is an array type.
The element type of the array type is <code>byte</code>.
</p>

An example on using this channel type.
<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
	"time"
	"crypto/rand"
)

func main() {
	c := make(chan *[16]byte)
	
	go func() {
		// Use double arrays to avoid data racing.
		var dataA, dataB [16]byte
		var data *[16]byte = &dataA
		for {
			_, err := rand.Read(data[:])
			if err != nil {
				c <- (*[16]byte)(nil)
			} else {
				c <- data

				// Swap the data array.
				if data == &dataA {
					data = &dataB
				} else {
					data = &dataA
				}
			}
		}
	}()
	
	for data := range c {
		if data == nil {
			break
		}
		fmt.Println((*data)[:])
		time.Sleep(time.Second / 2)
	}
}
</code></pre>

</div>

<h4>Example 4</h4>

<div>

<pre class="line-numbers"><code class="language-go">map[string][]func(int) int
</code></pre>

<p>
The <code>map</code> keyword on the left most indicates this type is a map type.
The key type of this map type is <code>string</code>.
The remaining right part <code>[]func(int) int</code> denotes the element type of the map type.
The <code>[]</code> indicates the element type is a slice type,
whose element type is a function type <code>func(int) int</code>.
</p>

An example on using this map type.
<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
)

func main() {
	plusone := func(x int) int {
		return x + 1
	}
	square := func(x int) int {
		return x * x
	}
	double := func(x int) int {
		return x + x
	}
	
	transforms := map[string][]func(int) int {
		"plus,plus,plus": {plusone, plusone, plusone},
		"square,plus,double": {square, plusone, double},
		"double,square,square": {double, double, square},
	}
	
	for _, n := range []int{2, 3, 5, 7} {
		fmt.Println(">>>", n)
		for name, transfers := range transforms {
			result := n
			for _, xfer := range transfers {
				result = xfer(result)
			}
			fmt.Printf("   %s: %d \n", name, result)
		}
	}
}
</code></pre>

</div>

<h4>Example 5</h4>

<div>

<pre class="line-numbers"><code class="language-go">[]map[struct{
	a int
	b bool
}]interface{
	Build(data []byte, struct{a int; b bool}) error
	Update(dt float64)
	Destroy()
}
</code></pre>

<p>
The startfing <code>[]</code> at the left most indicates this type is a slice type.
The following <code>map</code> keyword shows the element type of the slice type is a map type.
The <code>struct{a int; b bool}</code> literal enclosed in the <code>[]</code> following
the <code>map</code> keyword is the key type, a struct type with two fields, of the map type.
The element type of the map type is an interface type which specifies three methods.
</p>

To get a better readibility, we often use type declarations to composite
a complex type in multiple steps.
<pre class="line-numbers"><code class="language-go">type K struct{
	x int
	y bool
}
type E interface{
	fa([]byte, struct{x int; y bool})
	fb(int) struct{x int; y bool}
}
type T []map[K]E
</code></pre>

<p>
Although the type <code>T</code> and the unnamed type in the last example are two distict type,
and their values can be converted to each other, the memory layouts of their values are the same.
</p>

</div>

<h3>The Status Of The Built-in Generic Functionalites In Go</h3>

<p>
Besides the built-in generic for composite types,
there are several built-in functions also support generic.
Such as the built-in <code>len</code> function can be used to
get the length of values of arrays, slices, maps, strings and channels.
Generally, the functions in the <code>unsafe</code> standard package
are also viewed as built-in functions.
</p>

<p>
Go doesn't support generic for custom types and functions, at least for Go 1.
Although sometimes it is really inconvenient by lacking of custom generic support,
the built-in generic often alleviates the inconveniences.
In fact, Go has so many advantages in other aspects that
most Go programmers are happy in Go programming.
</p>

<!---

mention math package use float64 only ...

-->

<h3>The future Of Generic In Go</h3>

<p>
Go language design and development team
<a href="https://research.swtch.com/go2017#generics">wouldn't mind supporting generic feature in Go</a>,
it is just that they <a href="https://github.com/golang/go/issues/15292">haven't found a generic solution</a>
which will keep Go simple and clean yet.
So, it is possible that Go 2 will support custom generic.
</p>

