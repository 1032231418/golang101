<h1>More About Type Deductions In Go</h1>

<p>
If you have written Go code much, you should have already found that
the type deduction feature in Go brings much convinience to Go programming.
</p>

<h3>Recall Type Deduction Rules Mentioned Before</h3>

nil == nil is not allowed

<pre>
package main

import "fmt"

func main() {
	const a, b = 0xFFFFFFFF, 'a'
	var c = a + b // constant ('\x00' + 4294967392) overflows rune
	              // constant 4294967392 overflows rune
	var c int64 = a + b // ok
	// It looks the result type affect the constant expression comupation rule.
	fmt.Printf("%T, %x \n", c, c)
}
</pre>

<h3>One Specail Deduction Rule For Left Oprands In Bitwise Shift Operations</h3>

<pre>
https://groups.google.com/forum/#!topic/golang-nuts/sYnWNohBQH8

//var s uint = 3
const s uint = 3
var _ = uint8((255 << s) << s)
var _ uint8 = (255 << s) << s
var _ uint8 = 255 << ((256 >> s))
var _ = uint8((256 >> s) >> s)
var _ uint8 = (256 >> s) >> s
var _ float32 = 1<<s          // illegal: 1 has type float32, cannot shift
var _ = float64(1 << s)   // illegal: 1 has type float64, cannot shift
var _ = 1.0<<s         // illegal: 1.0 has type float64, cannot shift
var _ int = 1.0<<s         // ok
var _ = 1<<s != 1.0   // illegal: 1 has type float64, cannot shift
var _ = complex(1 << s, 1)

const ss = 1 // untyped
x := [3]int{}
_ = x[1.0 << ss] // ok
var u = 1.0<<ss // ok
var _ = 1.0<<1 // ok

const sss uint = 3 // typed costant
var u = 1.0<<sss         // ok
var u1 = 1.0<<sss != 0   // ok
var u2 = 1<<sss != 1.0   // ok
var v float32 = 1<<sss   // ok
var w int64 = 1.0<<33  // ok

Go spec:

var s uint = 33
var i = 1<<s           // 1 has type int
var j int32 = 1<<s     // 1 has type int32; j == 0
var k = uint64(1<<s)   // 1 has type uint64; k == 1<<33
var m int = 1.0<<s     // 1.0 has type int; m == 0 if ints are 32bits in size
var n = 1.0<<s == j    // 1.0 has type int32; n == true
var o = 1<<s == 2<<s   // 1 and 2 have type int; o == true if ints are 32bits in size
var p = 1<<s == 1<<33  // illegal if ints are 32bits in size: 1 has type int, but 1<<33 overflows int
var u = 1.0<<s         // illegal: 1.0 has type float64, cannot shift
var u1 = 1.0<<s != 0   // illegal: 1.0 has type float64, cannot shift
var u2 = 1<<s != 1.0   // illegal: 1 has type float64, cannot shift
var v float32 = 1<<s   // illegal: 1 has type float32, cannot shift
var w int64 = 1.0<<33  // 1.0<<33 is a constant shift expression

"The right operand in a shift expression must have unsigned integer
type or be an untyped constant representableby a value of type uint.
If the left operand of a non-constant shift expression is an untyped
constant, it is first converted to the type it would assume if the
shift expression were replaced by its left operand alone."
</pre>

<h3>Untyped <code>nil</code> As Arguments Of <code>append</code> And <code>copy</code> Function Calls</h3>

<pre>
func main() {
	var s []int
	_ = append(s, nil...) // okay
	_ = append(nil, s...) // error: first argument can't be untyped nil
	copy(s, nil)          // error: second argument can't be untyped nil
	copy(nil, s)          //
}
</pre>

<hr>



=================================

todo: move to constant and variable article

package main

import "unsafe"

func main() {
	println(MaxUint8_a == MaxUint8_b)
	println(MaxUint_a == MaxUint_b)
	println(MaxUint_a == MaxUint_c)
}

const MaxUint = ^uint(0)
const MaxInt  = int(^uint(0) >> 1)

const Is64bitOS = ^uint(0) >> 63 // 1 or 0
const WordBits = 32 << (^uint(0) >> 63) // 64 or 32

const MaxUint8_a uint8 = (1 << 8) - 1
const MaxUint_a uint = (1 << 64) - 1 // only works on 64-bit OSes

const MaxUint8_b = ^uint8(0)
const MaxUint_b = (1 << 64) - 1

const MaxUint_c = (1 << (unsafe.Sizeof(1) * 8)) - 1

const MaxInt  = int(^uint(0) >> 1)

const a = uint8(255) + uint8(1) // error: 256 overflows uint8
const b = int8(-128) / int8(-1) // error, 128 overflows int8


