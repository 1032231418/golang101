<h1>Basic Control Flows</h1>

<p>
The control flow blocks in Go are much like other popular programming languages,
but there are many differences.
This section will show these similarities and differences.
</p>

<div>
There are three kinds of basic control flow code blocks in Go:
<ul>
<li>
	<code>for</code> loop block.
</li>
<li>
	<code>if-else</code> two-way conditional execution block.
</li>
<li>
	<code>switch-case</code> multi-way conditional execution block.
</li>
</ul>

<p>
The basic control flow code blocks are much similar to the ones in many other popular languages,
but there are also many differences.
</p>

There are also some control flow code blocks which are related to certain kinds of types in Go.
<ul>
<li>
	<code>for-range</code> loop block for container types.
</li>
<li>
	<code>type-switch</code> multi-way conditional execution block for interface types.
</li>
<li>
	<code>select-case</code> block for channel types.
</li>
</ul>

<p>
Like many ohter popular languages, Go also supports <code>break</code>,
<code>continue</code> and <code>goto</code> code jump statements.
Beside these, there is a special code jump statement, <code>fallthrough</code>, in Go.
These statements are not simple statements.
</p>

<p>
There are some other kinds of control flows,
such as <a href="defer.html">deferred function calls</a>
and <a href="panic-and-recover.html">panic/recover mechanism</a>.
<a href="goroutine.htl">Goroutines</a> can also be viewed as a way of flow control.
</p>

<p>
Only the basic control flow code blocks and code jump statements will be explained
in the current article, other ones will be explained in many other articles in Go 101 series.
</p>
</div>

<h3>Expressions, Statements And Simple Statements</h3>

<p>
Before getting into the main topic, we need to know what are simple statements.
</p>

<p>
Statements control execution, this is the definition made by
<a href="https://golang.org/ref/spec#Statements">Go specification</a> for statements.
Most code lines in Go are statements.
The following to be introduced all kinds of control blocks are also all statements.
These control blocks are some more complex statements.
</p>

<p>
There is a special kind of statement, empty statement.
An empty statement looks empty and does nothing.
</p>

<p>
There are more kinds of statements.
However, Go 101 articles will not explain every statements.
What Go programmers should know are simple statements,
for some protions of the following to be introduced flow blocks must be simple statements.
</p>

<div>
Simple statements are special statements, a small subset of general statements.
In other words, not all statements are simple statements.
Then, which statements are simple statements?
The article <a href="simple-statement.yaml">simple statements in Go</a>
list all kinds of simple statements (six kinds).
Some of them will be introduced in follow up articles in Go 101.
Here, the current article will only use three kinds of them:
<ul>
<li>pure assignment statements</li>
<li>short variable declaration statements</li>
<li>empty statements</li>
custom function calls with all return absent
i++, i--
channel
</ul>

todo: remove the article: simple-statement.yaml

Please note, 
<ul>
<li>
	standard variable declarations are not simple statements.
</li>
<li>
	operator involoved expressions are not statements. 
</li>
</ul>
</div>

<p>
Please note, standard variable declarations are not simple statements.
</p>

<h3>Expressions</h3>

<p>
sime expressions are statement, some are not.
</p>


<p>
An expression, as a whole, might be used as an operand in another expression.
In other words, an expression might be used as a sub-expression.
</p>



simple statement list
* blank
* 
* 

the third part in for can be xxx simple statement.

<p>
Each expression is involves several operands.
Generally, an expression has one single return result (there are a few exceptions),
so the expression can be used as an operand in another expression.
However, a statement can't be used as an operand in other expressions.
</p>

<p>
Any solo value, including literals and the soon to be introduced variables and constants, can be viewed as expressions.
In fact, an expression with one single return result can often be called a value.
</p>

<p>
Simple statements are special statements.
Simple statement is a special concept in Go to make code look simple and clean.
<b>In Go code, some portions of all kinds of control flow blocks
can only be simple statements.</b>
</p>

<p>
All the operations by using the operators mentioned in the last sections are expressions.
</p>

<p>
Like C++, Go also supports <code>x++</code> and <code>x--</code>.
But unlike C++, Go doesn't support <code>++x</code> and <code>--x</code>.
Another difference is <code>x++</code> and <code>x--</code> are expressions in C++,
but they are both simple statements in Go.
In other words, they can't be used as sub expressions in other expressions.
</p>

<p>
Like many other languages, there are <code>op=</code> operators
where <code>op</code> can be an arithmetic operator or a bitwise operator
(but not a boolean operator).
Operations using such <code>op=</code> operators have no return values,
so they are not expressions. They are simple statements.
</p>

<p>
More simple statements and non-simple statements
will be pointed out when they are encountered later.
</p>

<h3><code>if-else</code> Control Flow Blocks</h3>

<div>
The full form of a <code>if-else</code> code block is
<pre class="line-numbers"><code class="language-go">if InitSimpleStatement; Condition {
	...
} else {
	...
}
</code></pre>
<p>
Like many other programming languages, the <code>else</code> block is optional.
</p>
<p>
The <code>InitSimpleStatement</code> part is also optional.
It must a simple statement, so it can be a short variable declaration form
or a value assignment, but can't be a standard variable declaration form.
<code>Condition</code> must be an expression which result is a boolean value.
The two parts following a <code>if</code> keyword can't be enclosed in <code>()</code>.
</p>

<p>
If the <code>InitSimpleStatement</code> in a <code>if-else</code> code block is present,
it will be executed before executing other statements in the <code>if-else</code> code block.
</p>

<p>
If the <code>InitSimpleStatement</code> in a <code>if-else</code> code block is a short variable declaration,
then the declared variables are only visible within the <code>if-else</code> code block.
</p>

Example:
<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano())
	x := rand.Int()
	
	if n := x % 2; n == 0 {
		fmt.Println(x, "is an even number.")
	} else {
		fmt.Println(x, "is an odd number.")
	}
	
	if x % 2 == 0 {
		fmt.Println(x, "is an even number.")
	} else {
		fmt.Println(x, "is an odd number.")
	}
	
	if n := x % 2; n == 0 {
		fmt.Println(x, "is an even number.")
	}
	
	if x % 2 == 0 {
		fmt.Println(x, "is an even number.")
	}
}
</code></pre>

todo: two or three scopes.
</div>

<h3><code>for</code> Loop Control Flow Blocks</h3>

<div>
The full form of a <code>for</code> loop code block is
<pre class="line-numbers"><code class="language-go">for InitSimpleStatement; Condition; PostSimpleStatement {
	...
}
</code></pre>
<p>
There are three parts following the <code>for</code> keyword.
The <code>InitSimpleStatement</code> and <code>PostSimpleStatement</code> parts
must be both simple statements, and the <code>PostSimpleStatement</code> part
must not be a short variable declaration.
This means the <code>InitSimpleStatement</code> part can be a short variable declaration
form or a value assignment, but can't be a standard variable declaration form.
<code>Condition</code> must be an expression which result is a boolean value.
</p>

<p>
If the <code>InitSimpleStatement</code> in a <code>for</code> loop code block is present,
it will be executed only once before executing other statements in the <code>for</code> loop code block.
</p>

<p>
If the <code>InitSimpleStatement</code> in a <code>for</code> loop code block is a short variable declaration,
then the declared variables are only visible within the <code>for</code> loop code block.
</p>

<p>
The <code>Condition</code> expression will be evaluated at each loop step.
If the evaluation result is <code>false</code>, then the loop will end.
Otherwise the body of the loop will get executed.
</p>

<p>
The <code>PostSimpleStatement</code> will be executed at the end of each loop step.
</p>

<p>
Unlike many other programming languages, the three parts following the <code>for</code>
keyword can't be enclosed in <code>()</code>.
</p>

A <code>for</code> loop example. The example will print the integers from
<code>0</code> to <code>9</code>, each on one line.
<pre class="line-numbers"><code class="language-go">for i := 0; i < 10; i++ {
	fmt.Println(i)
}
</code></pre>

The <code>InitSimpleStatement</code> and <code>PostSimpleStatement</code> parts
can be omitted. The form is can be called as condition-only <code>for</code> loop form.
It is the same as the <code>while</code> loop in other languages.
<pre class="line-numbers"><code class="language-go">var i = 0
for i < 10 {
	fmt.Println(i)
	i++
}
</code></pre>

The <code>Condition</code> part can also be omiited.
Like the <code>if</code> code block,
when the <code>Condition</code> part in a <code>for</code> loop is omitted,
Go compile will think the condition is <code>true</code>.
<pre class="line-numbers"><code class="language-go">for i := 0; ; i++ {
	fmt.Println(i)
	if i >= 10 {
		break
	}
}
</code></pre>
<p>
Note, here a <code>break</code> statement is used to make execution jump out of the
<code>for</code> loop block.
The <code>break</code> statement can be
used to jump out of the five kinds of code blocks mentioned above
(the once exception is the <code>if-else</code> block).
Only the innermost code block ( of the five kinds) which enclossed
the <code>break</code> statement will be jumped out of.
A <code>break</code> keyword can be followed by a label,
so that it can make execution jump out of any code block (of the five kinds)
which enclosed the <code>break</code> statement.
Below will explain labels in detail.
</p>

In fact, all the three parts following the <code>for</code> keyword can be omitted.
The form is can be called as bare <code>for</code> loop form.
It is the same as the <code>while(true)</code> loop in other languages.
<pre class="line-numbers"><code class="language-go">var i = 0
for {
	fmt.Println(i)
	i++
	if i >= 10 {
		break
	}
}
</code></pre>

For the full <code>for</code> loop form,
any of the three parts following the <code>for</code> keyword can be blank
(but the two <code>;</code> are still present).
<pre class="line-numbers"><code class="language-go">package main

func main() {
	var i int
	for i = 0; ; {
		break
	}
	
	for ; i < 10 ; {
		break
	}
	
	for ; ; i++ {
		break
	}
	
	for ; ;  {
		break
	}
}
</code></pre>

<p>
The last code block in the above example is equivalent to the bare <code>for</code> loop.
</p>

A <code>continue</code> statement can be used in a <code>for</code> loop block
to end the current loop step earlier and start the next loop step.
Here is an example to print all even integers under <code>10</code>.
<pre class="line-numbers"><code class="language-go">for i := 0; i < 10; i++ {
	if i%2 == 1 {
		continue
	}
	fmt.Println(i)
}
</code></pre>

todo: two scopes

</div>

<h3><code>switch-case</code> Control Flow Blocks</h3>

todo: be consistent with if and for.

<div>
The full form of the <code>switch-case</code> code block is some hard to describe clearly,
so here just shows an example to demo the full form:
<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
	"math/rand"
	"time"
)

func init() {
	rand.Seed(time.Now().UnixNano())
}

func main() {
	switch n := rand.Intn(100); n%9 {
	case 0:
		fmt.Println(n, "is a multiple of 9.")

		// Different from many other languages, in Go, the 
		// execution will automatically jumps out of the
		// switch-case block at the end of each branch block.
		// No "break" statement is needed here.
	case 1, 2, 3:
		fmt.Println(n, "mod 9 is 1, 2 or 3.")
	case 4, 5:
		fmt.Println(n, "mod 9 is 4 or 5.")
	default:
		fmt.Println(n, "mod 9 is 6, 7, or 8.")
	}
}
</code></pre>

<p>
In the abvoe example, <code>switch</code>, <code>case</code> and <code>default</code> are all keywords.
The <code>default</code> and <code>case</code> keywords each corresponds a nested branch code block.
</p>

<p>
There must not be expressions following the <code>default</code> keyword,
but there must be one expression following each <code>case</code> keyword.
</p>

The values following <code>case</code> keywords can be constants, literals, variables, or any other expressions.
Among all the boolean, numeric and string literals (including constants) following
all <code>case</code> keywords in a <code>switch-case</code> code block, there must not be two duplicated ones.
For example, the following code block is illegal, for the literal <cod>3</cod> follows two <code>case</code> keywords.
<pre class="line-numbers"><code class="language-go">switch n := rand.Intn(100); n%9 {
case 0:
	fmt.Println(n, "is a multiple of 9.")
case 1, 2, 3:
	fmt.Println(n, "mod 9 is 1, 2 or 3.")
case 3, 4, 5:
	fmt.Println(n, "mod 9 is 4 or 5.")
default:
	fmt.Println(n, "mod 9 is 6, 7, or 8.")
}
</code></pre>

There can be two parts following the <code>switch</code> keyword
in a <code>switch-case</code> code block, both are optional.
Like <code>if-else</code> and <code>for</code> loop code blocks,
the first part must be a simple statement and it will be executed before
other statements in the <code>switch-case</code> code block if it is present.
The second part must an expression which result should be a typed value.
<ul>
<li>
	If the second part is absent, Go compile will viewed it as typed
	<code>bool</code> value <code>true</code>.
</li>
<li>
	If the second part (an expression) is present and its result is an untyped value,
	then it must have a default type,
	so that Go compiler will view it as a typed value which type is the default type.
	For this reason, the second part can't be an untyped <code>nil</code>
	(which has not a default type).
</li>
<li>
	At run time, the typed value will be compared with the values following each <code>case</code> keyword,
	from top to bottom. If one value following a <code>case</code> keyword is equal to the typed value,
	then the corresponding nested branch code block of the <code>case</code> keyword will be executed.
</li>
</ul>

The <code>default</code> branch is optional, the same for any <code>case</code> branch.
So the following code blocks are all legal, but they are all no-ops.
<pre class="line-numbers"><code class="language-go">switch n := 5; n {
}

switch 5 {
}

switch {
}
</code></pre>

How to make the execution slip into the next branch?
There is a <code>fallthrough</code> keyword in Go to achieve this.
For example:
<pre class="line-numbers"><code class="language-go">switch n := rand.Intn(100); n%9 {
case 0:
	fmt.Println(n, "is a multiple of 9.")
case 1:
	fmt.Println(n, "mod 9 is 1.")
	fallthrough
case 2:
	fmt.Println(n, "mod 9 is 1 or 2.")
	fallthrough
case 3:
	fmt.Println(n, "mod 9 is 1, 2 or 3.")
}
</code></pre>

Please note, a <code>fallthrough</code> statement must be the final statement in a branch.
For example, the following <code>fallthrough</code> usages are both illegal.
<pre class="line-numbers"><code class="language-go">switch n := rand.Intn(100); n%9 {
case 0:
	fmt.Println(n, "is a multiple of 9.")
case 1:
	if true {
		fallthrough // fails to compile
	}
case 2:
	fallthrough // fails to compile
	fmt.Println(n, "mod 9 is 1 or 2.")
case 3:
	fmt.Println(n, "mod 9 is 1, 2 or 3.")
}
</code></pre>

<p>
The <code>fallthrough</code> statement can't show up in the final branch in a <code>switch-case</code> code block.
</p>

<p>
The <code>break</code> statement can also be used in any branch block of a <code>switch-case</code>
code block to make code execution jump out of the <code>switch-case</code> code block earlier.
Here will not show examples of using <code>break</code> statements in <code>switch-case</code> code blocks.
</p>

Another obvious differences from many other languages is the order of the <code>default</code> branch
in a <code>switch-case</code> code block can be arbitrary.
Example:
<pre class="line-numbers"><code class="language-go">func main() {
	// In the following code blocks, the second parts
	// following the "switch" keywords are all absent,
	// compile will view them as true (of type "bool").
	
	switch n := rand.Intn(3); {
	case n == 0: fmt.Println("n == 0")
	case n == 1: fmt.Println("n == 1")
	default: fmt.Println("n == 2")
	}
	
	switch n := rand.Intn(3); {
	default: fmt.Println("n == 2")
	case n == 0: fmt.Println("n == 0")
	case n == 1: fmt.Println("n == 1")
	}
	
	switch n := rand.Intn(3); {
	case n == 0: fmt.Println("n == 0")
	default: fmt.Println("n == 2")
	case n == 1: fmt.Println("n == 1")
	}
}
</code></pre>
</div>

<h3><code>goto</code> Statement And Label Declaration</h3>

<p>
Like many other languages, Go also supports <code>goto</code> statement.
A <code>goto</code> keyword must be followed a label to form a statement.
A label is declared with the form <code>LabelName:</code>,
where <code>LabelName</code> must be an identifier.
A label which name is not the blank identifier must be used,
by following a <code>goto</code> keyword, once it is declared.
</p>

<p>
A <code>goto</code> statement will make the execution jump to the next statement
following the declaration of the label used in the <code>goto</code> statement.
</p>

<p>
A label must be declared within a function body.
A use of a label can appear before or after the declaration of the label.
But any use of a label must appear within the innermost code block
which contains the declaration of the label.
</p>

<p><i>
(You can read <a href="block-and-scope.html">blocks and scopes in Go</a>
to get more information about code blocks and identifier scopes.)
</i></p>

<div>
<pre class="line-numbers"><code class="language-go">func main() 

</code></pre>

Note, if a label is declared before the declaration of a variable,
then the uses of the label can't appear within the scope of the variable.
The following code will fail to compile.
<pre class="line-numbers"><code class="language-go">func main() 

</code></pre>

To make the above code compile okay, the scope of the variable must be shrinked
by creating a new code block with <code>()</code>.
<pre class="line-numbers"><code class="language-go">func main() 

</code></pre>

<p>
With the new code block, the scope of the variable is from the end of its declaration
to the end of the new code block, instead of the end of the <code>main</code> function.
</p>

The innermost code block of a label use must be, or nested in,
the innermost code block containing the declaration of the label.

<pre class="line-numbers"><code class="language-go">package main

func main() {
	goto Label // goto Label jumps into block
	{
		Label:
		{
			goto Label // okay
		}
	}
	{
		goto Label // goto Label jumps into block
	}
}
</code></pre>

</div>

<h3><code>break</code> Statements With Labels</h3>

<div>
A <code>break</code> keyword can be followed a label or not.
A label following a <code>break</code> keyword must be declared just before
a code block which contains the respective <code>break</code> statement
and the code block must be of the following five kinds of code blocks:
<ul>
<li>
	<code>for</code> loop block.
</li>
<li>
	<code>for-range</code> loop block.
</li>
<li>
	<code>swtich-case</code> block.
</li>
<li>
	<code>type-switch</code> block.
</li>
<li>
	<code>select-case</code> block.
</li>
</ul>

<p>
The name of the label declared just before such a code block
can be viewed as the name of this code block.
In other words, we can use the label name to identify this code block.
</p>

<p>
The <code>break</code> keywords followed with a label must be within
the code block identified by the label.
Such <code>break</code> statements will make the execution jump out of
the code block identified by the label.

A <code>break</code> statement without a label will make the execution
jump out of the innermost control flow code block (of the just listed five kinds)
containing the <code>break</code> statement.
</p>

Generally, <code>break</code> statements with labels are used in inner nested code blocks,
to jump out of an outer nesting code block.
<pre class="line-numbers"><code class="language-go">func main() 

</code></pre>
</div>

<p>
A declared label must be used at lease once,
except the identifier of the label is the blank identifer <code>_</code>.
</p>

<h3><code>continue</code> Statements With Labels</h3>

<div>
<p>
Each <code>continue</code> keyword can also be followed a label or not.
A label following a <code>continue</code> keyword must be declared just before
a <code>for</code> loop or a <code>for-range</code> loop code block.
</p>

<p>
The <code>continue</code> keyword followed with a label must be within
the loop code block identified by the label.
Such a <code>continue</code> statement will end the current loop step
of the loop code block identified by the label (and start the next loop step).

A <code>continue</code> statement without a label will end the current loop step
of the innermost loop code block containing the <code>continue</code> statement.
</p>

Generally, <code>continue</code> statements with labels are used in inner nested loop code blocks,
to end the current loop step of an outer nesting loop code block.
<pre class="line-numbers"><code class="language-go">func main() 

</code></pre>
</div>

todo: some niche cases.
<pre class="line-numbers"><code class="language-go">package main

func main() {
	type T []int
	if 1 == (T{1,2,3}[1]) {
		
	}
	for 1 == (T{1,2,3}[1]) {
		
	}
	switch (T{1,2,3}[1]) {
		
	}
}
</code></pre>
