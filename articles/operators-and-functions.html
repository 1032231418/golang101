
<h1>Operators And Functions</h1>

<p>
This article will introduce two kinds of operations,
operator operation and function operations.
Only commonly used operators will be explained in this article.
Other operators will be introduced in other articles later.
The explainations for functions in this article are simple.
More detailed explainations for functions will made in another article later.
</p>

<h3>About Some Descriptions In Operator Explainations</h3>

<p>
This article will only introduce arithmetic operators, bitwise operators,
comparison operators, boolean operators and string concatenation operator.
These operators are either binary operators or unary operators.
A binary operator operation takes two operands and
a unary operator operation takes only one operand.
</p>

<p>
All the operator operations introduced in this articles each returns one result.
</p>

<div>

This article doesn't pursue the accuracy of some descriptions.
For example, when it says that a binary operator requires
the types of its two operands must be the same,
what it means is
<ul>
<li>
	if both of the two operands are typed values,
	then their types must be the same one,
	or one operand can be implicitly converted to the type of the other.
</li>
<li>
	if only one of the two operands is typed,
	then the other (untyped) operand can represent as
	a value of the typed of the typed operand.
</li>
<li>
	if both of the two operands are untyped values,
	then they must be both boolean values,
	both string values or both basic numeric values.
</li>
</ul>

Slimilarly, when it says an operator,
either a binary operator or a unary operator,
requires the type of one of its operands must be of a certain type,
what it means is
<ul>
<li>
	if the operand is typed, then its type must that certain type.
</li>
<li>
	if the operand is untyped, then the untyped value must
	be able to represent as a value of that certain type.
</li>
</ul>

<p>
</p>

</div>

<h3>Arithmetic Operators</h3>

<div>
<p>
Go supports five basic binary arithmetic operators:
</p>

<table class="table table-bordered text-center" style="width:100%;">
<thead>
	<tr class="active">
	<th class="text-center" style="white-space: nowrap;">Operator</th>
	<th class="text-center">Name</th>
	<th class="text-center">Requirements For The Two Operands</th>
	</tr>
</thead>
<tbody>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">+</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			addition
		</td>
		<td style="vertical-align: middle;" class="text-left" rowspan="4">
			The two operands must be both values of the same basic numeric type.
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">-</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			subtraction
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">*</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			multiplication
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">/</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			division
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">%</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			remainder
		</td>
		<td style="vertical-align: middle;" class="text-left">
			The two operands must be both values of the same basic integer type.
		</td>
	</tr>
</tbody>
</table>

<p>
The five operators are also often called <b>sum</b>, <b>difference</b>,
<b>product</b>, <b>quotient</b> and <b>modulo</b> operators.
Go 101 will not explain how these operator operations work in details.
</p>

<p>
Go supports six bitwise binary arithmetic operators:
</p>

<table class="table table-bordered text-center" style="width:100%;">
<thead>
	<tr class="active">
	<th class="text-center" style="white-space: nowrap;">Operator</th>
	<th class="text-center">Name</th>
	<th class="text-center">Requirements For The Two Operands And Mechanism Explainations</th>
	</tr>
</thead>
<tbody>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">&amp;</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			bitwise and
		</td>
		<td style="vertical-align: middle;" class="text-left" rowspan="4">
			<p>
			The two operands must be both values of the same integer type.
			</p>
			
			Mechanism explainations (a value with the subscript <code>2</code> is the binary literal form of the value):
			<ul>
			<li>
				<code>1100<sub>2</sub> &amp; 1010<sub>2</sub></code> 
				results <code>1000<sub>2</sub></code> 
			</li>
			<li>
				<code>1100<sub>2</sub> | 1010<sub>2</sub></code> 
				results <code>1110<sub>2</sub></code> 
			</li>
			<li>
				<code>1100<sub>2</sub> ^ 1010<sub>2</sub></code> 
				results <code>0110<sub>2</sub></code> 
			</li>
			<li>
				<code>1100<sub>2</sub> &^ 1010<sub>2</sub></code> 
				results <code>0100<sub>2</sub></code> 
			</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">|</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			bitwise or
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">^</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			bitwise xor
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">&amp;^</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			bitwise clear
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">&lt;&lt;</th>
		<td style="vertical-align: middle; white-space: nowrap;">
			bitwise left shift
		</td>
		<td style="vertical-align: middle;" class="text-left" rowspan="2">
			<p>
			The left operand must be an integer
			and the right operand must be an unsigned integer
			(or an <a href="type-system-overview.html#typed-and-untyped-values">untype</a>
			non-negative integer constant).
			</p>
			
			Mechanism explainations:
			<ul>
			<li>
				<code>1100<sub>2</sub> &lt;&lt; 3</code> 
				results <code>1100000<sub>2</sub></code> 
			</li>
			<li>
				<code>1100<sub>2</sub> &gt;&gt; 3</code> 
				results <code>1<sub>2</sub></code> 
			</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">&gt;&gt;</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			bitwise right shift
		</td>
	</tr>
</tbody>
</table>

<p>
Go also supports three unary arithmetic operators:
</p>

<table class="table table-bordered text-center" style="width:100%;">
<thead>
	<tr class="active">
	<th class="text-center" style="white-space: nowrap;">Operator</th>
	<th class="text-center">Name</th>
	<th class="text-center">Explainations</th>
	</tr>
</thead>
<tbody>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">+</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			positive
		</td>
		<td style="vertical-align: middle;" class="text-left">
			<code>+n</code> is equivalent to <code>0 + n</code>.
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">-</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			negative
		</td>
		<td style="vertical-align: middle;" class="text-left">
			<code>-n</code> is equivalent to <code>0 - n</code>.
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">^</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			bitwise complement<br/>
			(bitwise not)
		</td>
		<td style="vertical-align: middle;" class="text-left">
			<code>^n</code> is equivalent to <code>m ^ n</code>,
			where <code>m</code> is a value all of which bits are 1.
			For example,
			if the type of <code>n</code> is <code>int8</code>,
			then <code>m</code> is <Code>-1</code>,
			and if the type of <code>n</code> is <code>uint8</code>,
			then <code>m</code> is <code>0xFF</code>.
		</td>
	</tr>
</tbody>
</table>

Note,
<ul>
<li>
	in many other languages,
	bitwise-complement operator is denoted as <code>~</code>.
</li>
<li>
	like many other languages,
	the addition binary operator <code>+</code> can also be used as <b>string concatenation</b> operator,
	which will be introduced below.
</li>
<li>
	like C and C++ languages,
	the multiplication binary operator <code>*</code> can also be used as <b>pointer dereference</b> operator,
	and the bitwise-and operator <code>&amp;</code> can also be used as <b>pointer address</b> operator.
	Please read <a href="pointer.html">pointers in Go</a> for details later.
</li>
<li>
	unlike Java language, Go supports unsigned integer types,
	so the unsigned shift operator <code>&gt;&gt;&gt;</code> doesn't exist in Go.
</li>
<li>
	there is no power operator in Go, please use <code>Pow</code> funtion
	in the <code>math</code> standard package instead.
	Code package and package import will be introduced in the next article
	<a href="packages-and-imports.html">packages and imports</a>.
</li>
<li>
	the bitwise-clear operator <code>&amp;^</code> is a unique operator in Go.
	<code>m &amp;^ n</code> is equivalent to <code>m &amp; (^n)</code>.
</li>
</ul>

<p>
</p>

Example:
<pre class="line-numbers"><code class="language-go">func main() {
	var (
		a, b float32 = 12.0, 3.14
		c, d int16   = 15, -6
		e    uint8   = 7
	)

	// The ones compile okay.
	_ = 12 + 'A' // two untyped operands (both are numeric)
	_ = 12 - a   // one untyped operand and one typed operand
	_ = a * b    // two typed operands
	_ = c % d
	_, _ = c + int16(e), uint8(c) + e
	_, _, _, _ = a / b, c / d, -100 / -9, 1.23 / 1.2
	_, _, _, _ = c | d, c & d, c ^ d, c &^ d
	_, _, _, _ = d << e, 123 >> e, e >> 3, 0xF << 0
	_, _, _, _ = -b, +c, ^e, ^-1

	// The following ones fail to compile.
	_ = a % b   // error: a and b are not integers
	_ = a | b   // error: a and b are not integers
	_ = c + e   // error: type mismathing
	_ = b >> 5  // error: b is not an integer
	_ = c >> -5 // error: -5 is not representable as unsigned integers
	_ = c >> d  // error: d is not an unsigned integer
}
</code></pre>

<p>
</p>

</div>

<h4>About The Results Of Arithmatic Operator Operations</h4>

<div>

The result of a binary arithmetic operator operation
(except bitwise shift operations)
<ul>
<li>
	is a typed value of the same type of the two operands
	if the two operands are both typed values of the same type.
</li>
<li>
	is a typed value of the same type of the typed operand
	if only one of the two operands is a typed value.
	In the computation, the other (untyped) value will be deduced
	as a value of the type of the typed operand.
	In other words, the untyped operand will be implicitly
	converted to the type of the typed operand.
</li>
<li>
	is still an untyped value if both of the two operands are untyped.
	The default type of the result value is one of the two default
	types and the one appears latter in this list: <code>int</code>,
	<code>rune</code>, <code>float64</code>, <code>complex128</code>.
</li>
</ul>

The result of a bitwise shift operatior operation
<ul>
<li>
	is a typed value of the same type of the first (left) operand
	if the first operand is a typed value.
</li>
<li>
	is an untyped value if the first operand is an untyped value.
	The default type of the result is the same as the first operand.
</li>
</ul>

Example:
<pre class="line-numbers"><code class="language-go">func main() {
	const X, Y = 2, 'A' // two untyped values. Default types: int and rune.
	var a, b int = X, Y // two typed values.

	d := X + Y // the type of d is the default type of Y: rune (int32).
	e := Y - a // the type of e is the type of a: int.
	f := a * b // the type of f is the types of a and b: int.

	println(X, Y)    // 2 65
	println(d, e, f) // 67 63 130
}
</code></pre>

<p>
</p>

</div>

<h4>About Overflows</h4>

<div>

<p>
Overflows are not allowed for typed constant values
but are allowed for non-constant and untyped constant values,
either the values are intermediate or final results.
Overflows will be truncated (or wrapped around) for non-constant values,
but overflows (for default types) on untyped constant value
will not be truncated (or wrapped around).
</p>

Example:
<pre class="line-numbers"><code class="language-go">var a, b uint8 = 255, 1
var c = a + b  // okay: higher overflowed bits are truncated. c == 0
var d = a << b // okay: higher overflowed bits are truncated. d == 254
const X = 0x1FFFFFFFF * 0x1FFFFFFFF // okay, though the result overflows int.

// These lines fail to compile.
var e = X                // error: untyped constant X overflows int.
const Y = 128 - int8(1)  // error: 128 overflows int8
const Z = uint8(255) + 1 // error: the result 256 overflow uint8.
</code></pre>

<p>
</p>

</div>

<h4>About Divisions</h4>

<div>

<p>
The two operands in a division operator opeartion
can be both of any basic numeric type.
If their types is an integer type,
assume the two operands are <code>x</code> and <code>y</code>,
the integer quotient <code>q</code> (<code>= x / y</code>)
and remainder <code>r</code> (<code>= x % y</code>)
satisfy <code>x == q*y + r</code>, where <code>|r| < |y|</code>.
If <code>r</code> is not zero, its sign is the same as <code>x</code>
(the dividend).
The result of <code>x / y</code> is truncated towards zero.
</p>

<p>
If the divisor <code>y</code> is a constant, it must not be zero.
If the divisor is zero at run time and it is an integer,
a run-time panic occurs.
Panics is like exceptions in some other languages.
We can learn more about panics in the article
<a href="panic-and-recover.html">panic and recover</a> later.
</p>

Example:
<pre class="line-numbers"><code class="language-go">println( 5/3,   5%3)  // 1 2
println( 5/-3,  5%-3) // -1 2
println(-5/3,  -5%3)  // -1 -2
println(-5/-3, -5%-3) // 1 -2

println(5.0 / 3.0)     // 1.666667
println((1-1i)/(1+1i)) // -1i

var a, b = 1.0, 0.0
println(a/b, b/b) // +Inf NaN

_ = int(a)/int(b) // compile okay but panic at run time.

// The following two lines fail to compile.
println(1.0/0.0) // error: division by zero
println(0.0/0.0) // error: division by zero
</code></pre>

<p>
</p>

</div>

<h4>Using <code>op=</code> For Binary Arithmatic Operators</h4>

<div>

<p>
For a binary arithmetic operator <code>op</code>, <code>x = x op y</code>
can be shortened to <code>x op= y</code>.
In the short form, <code>x</code> will be only evaluated once.
</p>

Example:
<pre class="line-numbers"><code class="language-go">var a, b int8 = 3, 5
a += b
println(a) // 8
a *= a
println(a) // 64
a /= b
println(a) // 12
a %= b
println(a) // 2
b <<= uint(a)
println(b) // 20
</code></pre>

</div>

<h3>String Concatenation Operator</h3>

<div>

As above has mentioned, the addition operator can also be used as
string concatenation.

<table class="table table-bordered text-center" style="width:100%;">
<thead>
	<tr class="active">
	<th class="text-center" style="white-space: nowrap;">Operator</th>
	<th class="text-center">Name</th>
	<th class="text-center">Requirements For The Two Operands</th>
	</tr>
</thead>
<tbody>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">+</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			string concatenation
		</td>
		<td style="vertical-align: middle;" class="text-left">
			The two operands must be both values of the same string type.
		</td>
	</tr>
</tbody>
</table>

Example:
<pre class="line-numbers"><code class="language-go">println("Go" + "lang") // Golang
</code></pre>

<p>
</p>

<p>
If one of the two operands is a typed string, then the type of the result
string is the same as the type of the typed string.
If both the of the two oprands are untyped strings,
the result is also an untyped string value.
</p>

</div>

<h3>Boolean Operators</h3>

<div>
<p>
Go supports two boolean binary operators and one boolean unary operator:
</p>

<table class="table table-bordered text-center" style="width:100%;">
<thead>
	<tr class="active">
	<th class="text-center" style="white-space: nowrap;">Operator</th>
	<th class="text-center">Name</th>
	<th class="text-center">Requirements For Operand(s) And Mechanism Explainations</th>
	</tr>
</thead>
<tbody>
	<tr>
		<th scope="row" style="vertical-align: middle;" class="text-center" style="white-space: nowrap;">&amp;&amp;</th>
		<td style="vertical-align: middle;" class="text-center">
			boolean and (binary)
		</td>
		<td style="vertical-align: middle;" class="text-left" rowspan="2">
			The two operands must be both values of the same boolean type.
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle;" class="text-center" style="white-space: nowrap;">||</th>
		<td style="vertical-align: middle;" class="text-center">
			boolean or (binary)
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle;" class="text-center" style="white-space: nowrap;">!</th>
		<td style="vertical-align: middle;" class="text-center">
			boolean not (unary)
		</td>
		<td style="vertical-align: middle;" class="text-left">
			The type of the only operand must be a boolean type.
		</td>
	</tr>
</tbody>
</table>

<p>
We can use the <code>!=</code> operator introduced above as the <b>boolean xor</b> operator.
</p>

Mechanism explainations:
<pre><code class="language-go">// x      y     x && y     x || y    !x     !y
true    true    true       true     false  false
true    false   false      true     false  true
false   true    false      true     true   false
false   false   false      false    true   true
</code></pre>

<p>
If one of the two operands is a typed boolean, then the type of the result
boolean is the same as the type of the typed boolean.
If both the of the two oprands are untyped booleans,
the result is also an untyped boolean value.
</p>

</div>

<h3>Comparison Operators</h3>

<div>
<p>
Go supports six comparison binary operators:
</p>

<table class="table table-bordered text-center" style="width:100%;">
<thead>
	<tr class="active">
	<th class="text-center" style="white-space: nowrap;">Operator</th>
	<th class="text-center">Name</th>
	<th class="text-center">Requirements For The Two Operands</th>
	</tr>
</thead>
<tbody>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">==</th>
		<td style="vertical-align: middle; white-space: nowrap;">
			equal to
		</td>
		<td style="vertical-align: middle;" class="text-left" rowspan="2">
			If at least one operand is typed,
			then one operand must be able to be implicitly
			converted to the type of the other operand.
			Otherwise, the two operands must be both untyped booleans,
			both untyped strings or both untyped numeric values.
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle;" class="text-center">!=</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			not equal to
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">&lt;</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			less than
		</td>
		<td style="vertical-align: middle;" class="text-left" rowspan="4">
			The two operands must be both values of the same integer type,
			floating-point type or string type.
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">&lt;=</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			less than or equal to
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">&gt;=</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			larger than
		</td>
	</tr>
	<tr>
		<th scope="row" style="vertical-align: middle; white-space: nowrap;" class="text-center">&gt;=</th>
		<td style="vertical-align: middle; white-space: nowrap;" class="text-center">
			larger than or equal to
		</td>
	</tr>
</tbody>
</table>

<p>
The type of the result of any comparison operation is always an
<a href="type-system-overview.html#typed-and-untyped-values">untype</a> boolean value.
</p>

<p>
Later, if we say two values are comparable, we mean they can be compared
with the <code>==</code> and <code>!=</code> operators.
We will learn that values of which types are not comparable later.
Values of basic types are all comparable.
</p>

<p>
Please note that, not all real numbers can be accurately represented
in memory, so comparing two floating-point (or complex) values may
be not reliable. We should check whether or not the absolution of
the difference of two floating-point values is smaller than a small threshold
to judge whether or not the two floating-point values are equal.
</p>

</div>

<h3>Operator Precedences</h3>

<div>

<p>
The operator precedences may be also some different to other languages.
Here are the operator precedences in Go. Top ones have higher precedences.
The precedences of operators in the same line are same.
Like many other languages, <code>()</code> can be used to promote precedences.
</p>

<pre class="line-numbers"><code class="language-go">*   /   %   <<  >>  &   &^
+   -   |   ^
==  !=  <   <=  >   >=
&&
||
</code></pre>

<p>
</p>

One abvious difference to some other popular languages
is that the precedences of <code>&lt;&lt;</code> and
<code>&gt;&gt;</code> are higher than <code>+</code> and <code>-</code>.

</div>

<h3>More Operators</h3>

<div>
<p>
Same as C/C++,
there are two pointer related operators, <code>*</code> and <code>&amp;</code>.
Yes the same operator symbols as the multiplication and bitwise-and operators.
<code>&amp;</code> is used to take the address of an addressable value,
and <code>*</code> is used to deference a pointer value.
Unlike C/C++, in Go, values of pointer types don't support arithmetic operations.
For more details, please read <a href="pointer.html">pointers in Go</a> later.
</p>

<p>
There are some other operators in Go.
They will be introduced and explained in other articles of Go 101.
</p>

</div>

<p class="anchor" id="function"></p>
<h3>Simple Introduction For Function Declarations And Function Calls</h3>

<p>
The article <a href="function.html">functions in Go</a> will explain functions detailedly.
That article depends on some other knowledges which will be introduced later,
so it is not a good idea to read it now.
However, functions are so elemental in programming that
I think a simple introduction for function declarations and function calls
is needed at this time.
</p>

<div>
Let's view a function declaration:
<pre class="line-numbers"><code class="language-go">func Diff(a float64, b float64) (float64, bool) {
	return a - b, a > b
}
</code></pre>

We can find that, a function declaration is composed of several portions.
<ul>
<li>
	The first portion is the <code>func</code> keyword.
</li>
<li>
	The next portion is the function name, here it is <code>Diff</code>.
</li>
<li>
	The third portion is the input parameter definition list,
	which is enclosed in a <code>()</code>.
	Each parameter definition is a standard variable declaration
	but without the <code>var</code> keyword part in fact.
</li>
<li>
	The fourth portion is the result definition list.
	Go functions can return multiple results.
	For this specified example, the result definition list is also enclosed in a <code>()</code>.
	In fact, if the result definition list only contains most one identifier,
	then it needn't to be enclosed in a <code>()</code>
	If a function has no return results at all,
	then the fourth portion can be omitted totally.
</li>
<li>
	The last portion is the function body,
	which is enclosed in <code>{}</code>.
	In a function body, the keyword <code>return</code>
	is used to return results.
</li>
</ul>

Two more function declaration examples,
one has one return result and the other has no return results.

<pre class="line-numbers"><code class="language-go">// The result definition list doesn't need to be enclosed in a ().
func IsPositive(x float64) bool {
	return x > 0
}

// The result definition list of this function is omitted.
func doNothing() {
}
</code></pre>

<p>
A function call starts with the name of the called function.
The function name is followed by the argument list of the call.
The argument list must be enclosed in a <code>()</code>.
Each argument corresponds a parameter definition.
</p>

The following code snippet shows how to call the above declared functions.
<pre class="line-numbers"><code class="language-go">var x, a = Diff(3.2, 2.6)
var b = IsPositive(x)
doNothing()
</code></pre>

<p></p>
</div>

<p>
There are some minor variants in the syntaxes of function declarations.
Please read <a href="function.html">functions in Go</a>
for more information later.
</p>

<h4>Built-in Functions</h4>

<div>
<p>
There are some built-in functions in Go,
for example, the <code>println</code> and <code>print</code> functions.
We can call these functions without importing any packages.
</p>

<p>
We can use the built-in <code>real</code> and <code>imag</code> functions
to get the real and imaginary parts of a complex value. 
We can use the built-in <code>complex</code> function to produce a
complex value.
</p>

Example:
<pre class="line-numbers"><code class="language-go">const c = complex(1.6, 3.3) // c is a untyped complex constant.

// Here, real(c) and imag(c) are both untyped floating-point values.
var a, b float32 = real(c), imag(c)
var d = complex(a, b) // d is a typed value of type complex64.
var e = c             // e is a typed value of type complex128.

// real(d) and imag(d) are both typed values of type float32.
// real(e) and imag(e) are both typed values of type float64.
</code></pre>

<p>
More built-in functions will be introduced in other Go 101 articles.
</p>
</div>

