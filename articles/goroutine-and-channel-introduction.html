<h1>Goroutine And Channel Introduction</h1>

<p>
Modern CPUs often have multiple cores, and some CPU cores support hyper-threading.
In other words, moder CPUs can process multiple instruction pipelines simultaneously.
To fully use the power of modern CPUs, we need to do concurrent programming in coding our programs.
</p>

<p>
Go is famous for its built-in concurrent programming supports.
Two built-in features, goroutine and channel in Go,
lower the difficulties of concurrent programming much,
and make concurrent programming fun and enjoyable.
This article will make simple introduction for the two built-in concurrent programming features.
</p>

<h3>What Is Concurrent Programming?</h3>

<div>
<p>
Concurrent computing is a form of computing in which
several computations are executed during overlapping time periods.
The following picture depicts two concurrent computing cases.
In the picture, A and B represent two separate computations.
The second case is also called parallel computing, which is special concurrent computing.
<br/>
<img src="./res/concurrent-vs-parallel.png">
<br/>
</p>

<p>
Concurrent computing may happen in a program, a computer, or a network.
In Go 101, we only talk about program-level concurrent computing.
</p>

Concurrent computations may share resources, generally memory resource.
There are some circumstances may happen in a concurrent computing.
<ul>
<li>
	In the same period of one computation is writing data to a memroy segment,
	another computation is reading data from the same memroy segment.
	Then the integrity of the data read by the other computation might be not preserved.
</li>
<li>
	In the same period of one computation is writing data to a memroy segment,
	another computation is also writing data to the same memroy segment.
	Then the integrity of the data stored at the memroy segment might be not preserved.
</li>
</ul>

<p>
These circumstances are called data races.
One of the duties of concurrent programming is to control resource sharing among concurrent computations,
so that data races will not happen.                
The ways to achieve this duty is called concurrency synchronization, or data synchronization.
Go supports several data synchronization techniques.
Below will introduce one of them, channel.
</p>

Other duties of concurrent programming include
<ul>
<li>
	determine how many computations are needed.
</li>
<li>
	determine when to start and end a computation.
</li>
<li>
	determine how to distribute workload among concurrent computations.
</li>
</ul>

<p>
Many other programming languages implement concurrent computing
by create a OS thread for each individual concurrent computation.
In Go, there is not a formal way to explicitly create a OS thread.
In Go, concurrency is achieved through goroutines.
</p>
</div>

<p class="anchor" id="goroutine"></p>
<h3>Goroutines</h3>

<div>
<p>
Goroutines are also often called green threads.
Green threads are maintained and scheduled by language runtime instead of operation systems.
The cost, such as memory consumption and context switching,
of a goroutine is much smaller than a OS thread.
So it is not a problem for a Go program to maintain tons of thoundsands
goroutines at the same time, as long as the system memory is sufficient.
</p>

<p>
At initial, each Go program starts only one goroutine, the main goroutine.
A goroutine can create new goroutines.
It is super easy to create a new goroutine in Go,
just make a function call follow a <code>go</code> keyword,
then the function will be invoked in a new created goroutine.
The new created goroutine will exit alongside the return of the function call.
</p>

In the following example,
<code>Hello</code> is printed in the main goroutine,
meanwhile <code>Goodbye</code> is printed in a new created goroutine.
The new goroutine is created in the main goroutine.
Once the new goroutine starts, it will run with the main goroutine concurrently.
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	fmt.Println("Hello")
	go fmt.Println("Goodbye")
}
</code></pre>

<p>
The above program is expected to print two lines.
However, when you run it, it is very possible that the <code>Goodbye</code> line is not printed.
Why? The cause is that <b>a program will exit if the main goroutine exits</b>.
Although the new gorutine has started,
the code in it, the second <code>fmt.Println</code> call,
has not got a chance to return before the program exits.
This is why the <code>Goodbye</code> line is not printed.
</p>

We can let the main goroutine sleep for a while to give a chane for new goroutine to complete.
<pre class="line-numbers"><code class="language-go">package main

import "fmt"
import "time"

func main() {
	fmt.Println("Hello")
	go fmt.Println("Goodbye")
	
	time.Sleep(time.Second) // wait a while
}
</code></pre>

<p>
Now, both of the two lines are printed.
Here, the <code>time.Sleep</code> workaround can be viewed as a synchronization.
However, the workaround is defective.
It is a non-guaranteed way to avoid the main goroutine existing too early,
though it often works in practice for this specified example.
Go doesn't make the guarantee that the <code>fmt.Println("Goodbye")</code> call
will always return before the main goroutine ends the sleeping.
</p>

<p>
We will use channel to make a perfect synchronization below.
</p>

</div>

<p class="anchor" id="channel"></p>
<h3>Channel Types And Channel Values</h3>

<p>
Channel is a unique built-in feature in Go.
It makes the synchronizations among goroutines easy, flexible and fun.
</p>

<p><i>
(For detailed explainations of channels,
please read <a href="channel.html">concepts and rules of Go channels</a>.
Here only a simple introduction of channel will be made.)
</i></p>

<p>
A channel value can be viewed as a FIFO (first in, first out) data queue.
The operations, such as send data to the channel and receive data from the channel,
are all synchronized so that we don't need to make further synchronizations for them.
</p>

<p>
A bidirectional channel type is denoted as <code>chan T</code>,
where <code>T</code> is the element type of the channel type.
A channel value must be initialized with the built-in <code>make</code> function.
<code>make(chan T, N)</code> will create a bidirectional channel,
where <code>N</code> is called the capacity of the channel.
The argument <code>N</code> is an integer and it is optional.
<code>make(chan T)</code> is equivalent to <code>make(chan T, 0)</code>.
Channels with zero capacity are called unbuffered channels,
and channels with non-zero capacity are called buffered channels.
</p>

<p>
For a bidirectional channel <code>c</code> of type <code>chan T</code>
and a value <code>v</code> of type <code>T</code>,
we can use the channel send simple statement <code>c &lt;- v</code> to send
<code>v</code> into channel <code>c</code>, and use the expression <code>&lt;- c</code>
to receive a value from channel <code>c</code>.
</p>

<div>
For an unbuffered channel, a goroutine will be blocked when:
<ol>
<li>
    the goroutine tries to receive a value from the channel but
    there are no other (blocking) goroutines trying to send values to the channel.
    The goroutine will keep in blocking
    until another goroutine sends a value to the channel.
</li>
<li>
    the goroutine tries to send a value to the channel but
    there are no other (blocking) goroutines trying to receive value from the channel.
    The goroutine will keep in blocking until another
    goroutine tries to receive a value from the channel.
</li>
</ol>

Here is the modified version of the last example
by making use of a channel to do synchronization.
Go makes the guarantee that the start of the receive operation in main goroutine
happens after the completion of the send operation in the new created goroutine.
So the <code>fmt.Println("Goodbye")</code> call returns before the program exits for sure.
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	done := make(chan bool)
	
	fmt.Println("Hello")
	go func() {
		fmt.Println("Goodbye")
		done <- true // send a value
	}()
	
	<-done // receive a value (and ignore it)
}
</code></pre>

A little more complex example by using the received values.
In this example, the main goroutine and the <code>peer</code> goroutine make a talk.
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func peer(c chan int) {
	greeting := <-c
	fmt.Println(greeting) // Hello
	c <- "Goodbye"
}

func main() {
	c := make(chan int)
	go peer(c)
	c <- "Hello"
	greeting := <-c
	fmt.Println(greeting) // Goodbye
}
</code></pre>
</div>

<p><i>
(There are many channel use cases/patterns, please read
<a href="channel-use-cases.html">channel use cases</a> for details.)
</i></p>

<h3>Goroutine States</h3>

<!---
goroutine states
* runnable
  * running
  * queuing
* blocking
not good, a sleeping is in queuing or running?
-->

<p>
As the above channel examples have shown,
a live goroutine may stay in (and switch between) two states,
<b>running</b> and <b>blocking</b>.
</p>

<p>
A goroutine in sleeping (by calling <code>time.Sleep</code> function)
or waiting the response of a syscall is viewed as staying in running state.
</p>

<div>
A goroutine may enter blocking state when it
<ul>
<li>
	tries to send a value to a channel.
</li>
<li>
	tries to receive a value from a channel.
</li>
<li>
	tries to acquire a mutex lock.
</li>
<li>
	starts to wait a signal from other goroutines
	by calling the <code>Wait()</code> method of
	a value of the <code>WaitGroup</code> type or <code>Cond</code>
	type in the <code>sync</code> standard package.
</li>
</ul>

<p><i>
(Please read <a href="concurrent-synchronization-overview.html">concurrency synchronization overview</a>
to get more about synchronization techniques in Go.)
</i></p>

<p>
When a new goroutine is created, it will enter running state automatically.
Goroutines can only exit from running state, and never from blocking state.
If, for any reason, a goroutine stays in blokcing state for ever, then it will never exit.
Such case should be avoided in concurrent programming,
if it happens, it causes memory leak and should be viewed as logic bug.
</p>

As a blocking goroutine can only be unblocked by an action happens in other goroutines,
if all goroutines in a Go program are in blocking state,
then all of they will stay in blocking state for ever.
This can be viewed as an overall deadlock.
For such cases, the official Go runtime will crash the program.
For example:
<pre class="line-numbers"><code class="language-go">package main

func main() {
	c := make(chan string)
	
	go func() {
		<- c // blocks here
	}()

	<- c // also blocks here
}
</code></pre>

The two goroutines both try to receive value from a channel,
but no one sends values to the channel.
so the program will crash with the following output:
<pre class="output"><code>fatal error: all goroutines are asleep - deadlock!

goroutine 1 [chan receive]:
...
</code></pre>
</div>

<h3>Goroutine Schedule</h3>

<p>
We can call <code>runtime.NumCPU</code> to get the number of logical CPUs usable by the current running program.
The number of live running goroutines may be much larger than the number of logical CPUs.
Each logical CPU can only exexute one goroutine at any given time.
Go runtime must frequently switches execution contexts among goroutines
to let each running goroutine have chances to execute.
This is similar to how operation systems switch execution contexts among OS threads.
</p>

<p>
The official Go runtime adopts the
<a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw">M-P-G model</a>
to do the goroutine schedule job,
where <b>M</b> represents OS threads,
<b>P</b> represents logical/virtual processors (not logical CPUs)
and <b>G</b> represents goroutines.
Most the schedule work is made by logical processors (<b>P</b>s),
which act as brokers by attach goroutines (<b>G</b>s) to OS threads (<b>M</b>s).
Each OS thread can only be attached most one goroutine at any given time,
and each gproutine can only be attached to most one OS thread at any given time.
A goroutine can only get executed when it is attached to an OS thread.
A goroutine which has been executed for a while will try to detach itself from the corresponding OS thread,
so that other running goroutines can have chances to get attached and executed.
</p>

<p>
At runtime. we can call <a href="https://golang.org/pkg/runtime/#GOMAXPROCS">the <code>runtime.GOMAXPROCS</code>
function</a> to set the maximum number of logical CPUs that can be executing simultaneously.
The initial value of the number is determined by the <code>GOMAXPROCS</code> environment variable.
In fact, for the official Go runtime, this number determines the number of logical processors (<b>P</b>s).
For the official Go runtime, before Go 1.5, the default value of this number is <code>1</code>,
but since Go 1.5, the default value of this number is equal to
the number of logical CPUs usable by the current running program.
The default value (the number of logical CPUs) is the best choice for most programs.
</p>

<h3>The Cost Of Goroutines</h3>

<p>
The cost of a new goroutine is very small in Go.
It is okay for a Go program to create thounsands of, even millions of,
concurrent goroutines, as long as there is enough memory.
</p>

<h3>Goroutine Function Value Evaluation</h3>

<div>
<p>
If the start function of a new goroutine to be created
is evaluated to a <code>nil</code> function value, program will crash.
The crash is not recoverable.
</p>

Example:
<pre class="line-numbers"><code class="language-go">package main

func main() {
	var f func() // f == nil
	go f() // fatal error: go of nil func value
}
</code></pre>
</div>

<h3>The Evaluation Moment Of Goroutine Arguments</h3>

<div>
<p>
The arguments of the start function call of a goroutine are evaluated when the goroutine is created,
whereas the values used in a statement within the start function body are evaluated
when the statement is executed.
</p>

For example, the following program will print three lines. Each line contains two numbers.
Here is one possible output:
<pre class="output"><code>2 3
0 3
1 3
</code></pre>

The first number at each line will be <code>0</code>, <code>1</code> and <code>2</code> respectively,
though the orders of the three numbers might be not constant for every run.
However, the second number at each line will be always <code>3</code> for every run.
The reason is the second arguments in the <code>log.Println</code> calls are all
the iteration variable of the first loop, and the iteration variable has already become
to <code>3</code> when the <code>log.Println</code> calls are executed.
<pre class="line-numbers"><code class="language-go">package main

import "log"

func main() {
	log.SetFlags(0)
	
	const N = 3
	ready, done := make(chan int), make(chan int)
	
	for i := 0; i < N; i++ {
		go func(k int) {
			<-ready
			log.Println(k, i) // the arguments will be evaluated
			                  // when the log function is executed.
			done <- i
		}(i) // the argument will be evaluated on goroutine creation.
	}
	
	// The log.Println calls in the new goroutines will not executed
	// before the second loop gets executed.
	for i:= 0; i < N; i++ {
		ready <- i
	}
	
	// Wait until all the log.Println calls have been executed.
	for i:= 0; i < N; i++ {
		<-done
	}
}
</code></pre>

<p>
Please note that, this program uses the print functions in the
<code>log</code> standard package instead of the <code>fmt</code> standard package.
The reason is <b>the print functions in the <code>log</code> standard package
are synchronized between goroutines,
but the ones in the <code>fmt</code> standard package are not</b>.
If we use the print functions in the <code>fmt</code> standard package,
the output texts may interlace with each other.
</p>
</div>




