

<p>
Go is known for its simple and clean syntax.
This article will show some simple Go programs so that
new Go programmers will get a basic impression of Go code structures.
This article will only made some simple explainations for all kinds of
code elements and control flows.
Detailed explainations will come in following articles
in <a href="101.html">Go 101</a> the article series.
</p>

<p><i>
(This article assumes readers know what are types and functions.)
</i></p>

<h3>Install Go SDK</h3>

<p>
Firstly, please make sure
<a href="https://golang.org/doc/install">the official Go SDK</a> is installed on your computer.
The article <a href="introduction.html">An Introduction Of Go</a>
has mentioned that the Go compiler included in the official Go SDK is called <code>gc</code>.
In the Go 101 article series, all examples are compiled with <code>gc</code>.
</p>

<p>
The version of an official Go SDK release is consistent with
the highest Go language verison the release supports.
For example, Go SDK 1.9.x supports all Go versions from Go 1.0 to Go 1.9.
</p>

<p>
The path to the <code>bin</code> subfolder under the Go SDK installation root path
must be put in the <code>PATH</code> environment variable to invoke the tools in the SDK.
</p>

<p><i>
(Before Go SDK 1.9, a <code>GOROOT</code> environment variable must be configured
as the root path of the SDK installation.
<a href="https://golang.org/doc/go1.9#goroot">Since Go SDK 1.9</a>,
this environment variable becomes optional and is recommended not to set it.)
</i></p>

<p>
Before Go SDK 1.8, a <code>GOPATH</code> environment variable must be set.
<a href="https://golang.org/doc/go1.8#gopath">Since Go SDK 1.8</a>,
the default value of this environment variable is the path of the <code>go</code>
folder under the home directory of the current user.
If you don't like the default path as your <code>GOPATH</code>,
you still need to specify it manually.
The <code>GOPATH</code> environment variable can contain multiple paths.
</p>

<p>
The <code>bin</code> subfolder under the first path specified in
the <code>GOPATH</code> environment variable is highly recommended
to be put in the <code>PATH</code> environment variable to invoke
some third-party Go tools.
</p>

<p>
Up to Go 1.9, the official Go SDK recommends all of
your Go packages (which will be introduced below) are put
in the <code>src</code> subfolder under any path specified
in the <code>GOPATH</code> environment variable,
especially when a Go project depends on some third party packages.
However, all examples in Go 101 series are very simple so that
you can put the example files in any folder.
</p>

<h3>The Simplest Go Program</h3>

<div>
The following program is the simplest program in Go world.
<pre class="line-numbers"><code class="language-go">package main

func main() {
}
</code></pre>

<p>
The official Go SDK requires that every Go source code file
must ends with a <code>.go</code> extension.
Here, we assume the above source code saved in a file
named <code>simplest-go-program.go</code>.
</p>

Some explainations:
<ul>
<li>
	Like many other languages, Go project are also organized with code packages.
	Code packages are often called packages simply.
	The first line indicates which package the source file belongs to.
	<code>package</code> is a keyword, and <code>main</code> is the package name.
	Package names must be non-blank identifiers.
</li>
<li>
	The second line is a blank line, to make the code more readable. 
</li>
<li>
	The third and the fourth lines declare a function.
	<code>func</code> is a keyword.
	<code>main</code> is the function name.
	Function names must be identifiers.
	The <code>main</code> function is the entry function of the program.
	It has neither input parameters nor return results.
</li>
</ul>

<p>
<b>
There must be a <code>main</code> package which contains a
<code>main</code> function without any input parameters and return results.
</b>
These are the minimum requirements for any normal Go program.
</p>

<p>
Later, we will call packages satisfy the minimum requirements as
<b>program main package</b>, and call other packages as library packages.
</p>
</div>

<h3>Run Go Programs</h3>

<p>
Open a terminal and enter the folder which contains the above source file,
then run <code>go run simplest-go-program.go</code>.
Nothing is outputted? Yes, this program does nothing.
</p>

<p>
You can run <code>go</code> command without any arguments to
show what subcommands are supported.
</p>

<p>
The <code>go run</code> command is not recommended to compile and run formal Go projects.
It is just a convenient way to run simple Go programs,
just like the ones in the Go 101 article series.
For formal Go projects,
the <code>go build</code> and <code>go install</code> commands should be used instead.
The Go 101 article series will not explain
<a href="https://golang.org/cmd/go/">how to use the tools</a>
provided by the official Go SDK in detail.
</p>

<p>
Please note, in Go, a code line can't be break at an arbitrary position.
<a href="#line-break-rule">This section</a> below will list the line break rules in Go.
We can use the <code>go fmt</code> command to format Go source files.
</p>

<h3>About Code Package</h3>

<p>
For a formal package, all source files contained in the package folder
must all belong to the package. In other words, one folder shouldn't
contain multiple code packages.
</p>

<p>
The name of a package is not required to be the same as the package folder.
But for most packages, it is recommended to keep the two names identical.
The reason will be explained in following sections.
</p>

<p>
Following sections will introduce how to delare all kinds of resources,
such as variables, constants, types and functions.
The resources declared which are delared in the package block
are called package level resources, comparing to the resources
declared in function bodies, which are called local resources correspondingly.
</p>

<p>
The next section will introduce package import.
When a package is imported to other packages,
only the exported (or public) resources are visible to importing source files.
Exported resources are the non-local resources which identifiers each
starts with a Unicode upper case letter (Unicode class "Lu").
</p>

<p>
Non-exported (protected) package level resources declared in a package
are visible to all source files under the folder of the package.
</p>

<h3>Package Import</h3>

<div>
Let's check a small program which is a little more complex than the last one.
<a href="https://golang.org/pkg/fmt/">the <code>fmt</code> package</a>.

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	fmt.Println("Go has", 25, "keywords.")
}
</code></pre>

This program appends two new lines on the last one. Some Explainations:
<ul>
<li>
	The third line imports another package, the standard <code>fmt</code> package.
	There are many format functions declared in this package.
	The most used one may be the <code>Println</code> function,
	which will print the string representations of a sequence values to standard output.
	A space character is inserted between each two consecutive string representations
	and a newline character will be print in the end.
</li>
<li>
	The sixth line calls the <code>Println</code> function.
	Note that the function name is prefixed a <code>fmt.</code> in the call,
	where <code>fmt</code> is the name of the package containing the called function.
	The form <code>fmt.Println</code> is called a
	<a href="https://golang.org/ref/spec#Qualified_identifiers">qualified identifier</a>.
</li>
</ul>

Assume the solo source file of this program is <code>simple-import-demo.go</code>,
run this program will get the following output:
<pre class="output">
$ go run simple-import-demo.go
Go has 25 keywords.
$ 
</pre>

<p>
Note that the first charactor of the identifier <code>Println</code> is an upper case letter.
Otherwise, it will not be exported to the importing source files.
</p>

<p>
There are two built-in functions, <code>print</code> and <code>println</code>,
which have similar functionalites as the corresponding functions in the
<code>fmt</code> standard package.
Built-in functions can't used without importing any packages.
However, the two functions are not recommended to be used in production enviroments,
for they are not guaranteed to stay in the future Go versions.
</p>

<p>
All standard packages are listed <a href="https://golang.org/pkg/">here</a>.
</p>

<p>
A package import is also called an import declaration in Go.
An import declaraton is only visible to the source file which contains the import declaration.
It is not visible to other source files in the same package.
</p>

If multiple packages are imported into a source file,
we can group them in one import declaration by using <code>()</code>.
<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
	"math/rand"
)

func main() {
	fmt.Printf("Next pseudo-random number is always %d.\n", rand.Int())
}
</code></pre>

Some explainations:
<ul>
<li>
	the two packages can be imported in seperated two single-package import declarations.
</li>
<li>
	the last token in an import path will be used as the first part in a qualified identifier.
	For example, here <code>rand.</code> instead of <code>math/rand.</code> is used
	as the prefix of the <code>Int</code> function call.
</li>
<li>
	<code>Printf</code> is another common used function
	in the <code>fmt</code> standard package.
	The first argument of the <code>Printf</code> function call must be a string value.
	The <code>%d</code> in the first argument will be replaced with
	the string representation of the second argument in printing.
	The <code>\n</code> in a double-quote stle string literal
	will be escaped as a newline character.
</li>
</ul>

<p>
Note, if we expect the above program to produce a different random number.
We can should set a different seed by call the <code>rand.Seed</code> function
when the program just starts.
</p>
</div>

<h3>About Package Folder Names</h3>

<p>
The official Go tools recommend, and often require, the folder
containing a third-party package to be placed under the <code>src</code>
folder of any path specified in the <code>GOPATH</code> environment variable,
either directly or indirectly.
The import path of the third-party package is the relative path of
the package folder to the <code>src</code> folder.
The seperators in the path must be always <code>/</code> and can't be <code>\</code>.
For example, if a package is put under <code>aGoPath/src/a/b/pkg</code>,
then its import path is <code>/a/b/pkg</code>.
</p>

<p>
For the official Go SDK,
a standard package has a higher priority to be imported than a third-party package
if their import paths are identical.
So please try to avoid using the import paths of standarad packages
as import paths of third-party packages.
</p>

<p>
As above has mentioned, the name of folder containing a package
is not required to be the same as the package name.
However, for library packages, it will make package users confused if the name
of a package is different from the name of the package folder.
For example, if the name of a package is <code>foo</code> but its import path is
<code>x/y/bar</code>, then to call a function <code>F</code> in the package,
people may expect to use the qualified identifier <code>bar.F</code>.
However, in fact the correct qualified identifier is <code>foo.F</code>.
Package users must open the package source files to check what
the real package name is.
So please try to make the two names identical for every library package,
Every standard package has the same name as its folder name.
</p>

<p>
Packages named <code>main</code> are not recommended to be imported as library packages.
Although Go specification doesn't forbid importing <code>main</code> packages,
the official Go tools do (at least for Go SDK 1.9),
even if the <code>main</code> packages are not program packages.
</p>

<p>
In fact, in practice, to avoid confusions,
it is best never to use <codde>main</codde> packages as library packages.
It is a convention that <codde>main</codde> should be program packages.
</p>

<p>
For program <code>main</code> packages,
it is recommended to give each <codde>main</codde> package folder a meaningful name,
instead of the boring name <code>main</code>.
</p>

<div>
The official Go SDK will view package folders named as <code>internal</code>
and <code>vendor</code> as special package folders.
<ul>
<li>
	An <code>internal</code> package can only be imported by the packages
	which folders are the containing folders (inlcuding indirect ones) of the
	<code>internal</code> package folder.
	In other words, a package can't import an <code>internal</code> package
	which is not in the subtree of the importing package folder.
</li>
<li>
	The <code>vendor</code> folder under a package folder is used to
	store the dependency packages of the package.
</li>
</ul>

<p>
The Go 101 article series will not explain Go SDK related topics in detail.
Readers can read <a href="https://golang.org/cmd/go/#hdr-Internal_Directories">the
offcial documentation</a> for details.
</p>
</div>

<h3>Package Load Order</h3>

<p>
Go doesn't support circular dependency.
If package <code>a</code> imports package <code>b</code>
and package <code>b</code> imports package <code>c</code>,
then package <code>c</code> can't import package <code>a</code> and <code>b</code>,
package <code>b</code> also can't import package <code>a</code>.
</p>

<p>
A package also can't import itself.
</p>

<p>
At run time, packages are loaded by their dependency orders.
A package will be loaded after all the packages imported by it.
The load orders of two packages which have no dependency relations
are not specified in Go specification.
</p>

<h3>The <code>init</code> Functions</h3>

<p>
There can be multiple functions named as <code>init</code> declared in one package,
even in one source code file.
The functions named as <code>init</code> must have no any
input parameters and output results.
</p>

<p>
The <code>init</code> functions in a package will be called
once and only once sequentially when the package is loaded.
However, the invocation order of these <code>init</code> functions
is not specified in Go specification.
So there shouldn't be dependency relations between the
<code>init</code> functions in one package.
</p>

<p>
An <code>init</code> function in an importing package
will be called after all the <code>init</code> functions
declared in the packages imported by the importing package for sure.
</p>

<p>
All <code>init</code> functions in all involved packages in a program
will also be called sequentially, and all of them will be called
before invoking the <code>main</code> entry function.
</p>

<p>
The invocation order of the <code>init</code> functions in a package
is not specified in Go specification.
So there shouldn't be dependency relations between the
<code>init</code> functions in any package.
</p>

<div>
Here is a simple example which contains two <code>init</code> functions:

<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
	"time"
)

var startTime time.Time
func init() {
	startTime = time.Now()
}

func init() {
	time.Sleep(time.Second * 3 / 2)
}

func main() {
	fmt.Println(time.Since(startTime), "has passed.")
}
</code></pre>

<p>
For the official Go compiler, the <code>init</code> functions in a source file
will be called from top to down.
</p>

Run it, get the following output:
<pre class="output">
1.500208731s has passed.
</pre>
</div>

<p>
This example imports the <code>time</code> standard package,
which provides many time realated utilities.
Function <code>time.Now()</code> returns a value of type <code>time.Time</code>.
The function <code>time.Since</code> returns a value of <code>time.Duration</code>
which represents the difference from a specified <code>time.Time</code> value
and <code>time.Now()</code>.
</p>

<h3>Full Package Import Form</h3>

<p>
In fact, the full form of an import declaration is
<code>import importname "path/to/package"</code>,
where <code>importname</code> is optional,
its default value is the real name of the imported package.
In fact, the prefix token used in qualified identifiers is the <code>importname</code>.
</p>

<p>
The full import declaration form is not used widely.
However, sometimes we must use it.
For example, if a source file imports two packages with the same name,
to avoid making compiler confused, we must use the full import form
to set a custom <code>importname</code> for at least one package in the two.
</p>

<div>
Here is an example of using full import declaration forms.
Please note that green texts are comments.
<pre class="line-numbers"><code class="language-go">package main

// import declarations don't need to be grouped together.
import (
	format "fmt"
	random "math/rand"
	"time"
)

func main() {
	random.Seed(time.Now().UnixNano()) // set the random seed
	format.Print("A pseudo-random number: ", random.Int(), "\n")
	
	// The following two lines don't compile.
	/*
	rand.Seed(time.Now().UnixNano()) // set the random seed
	fmt.Print("A pseudo-random number: ", rand.Int(), "\n")
	*/
}
</code></pre>

Some explainations:
<ul>
<li>
	like many other languages,
	the texts following two slashes <code>//</code> are short comments,
	and long comments can be emclosed between a pair of
	<code>/*</code> and <code>*/</code>.
</li>
<li>
	we must use <code>format</code> and <code>random</code> as the
	prefix token in qualified identifiers, instead of the real package names.
</li>
<li>
	type <code>time.Time</code> has a method (methods will be explained later in another artcile)
	<code>UnixNano</code>, which return the number of nanoseconds
	(an <code>int64</code> value) elapsed since January 1, 1970 UTC.
	Here, the number of nanoseconds is used as the random seed.
</li>
<li>
	<code>Print</code> is another function in the <code>fmt</code> standard package.
	It will print the string representations of the passed arguments, one by one.
	If two consecutive arguments are both string values,
	then a space will be inserted between them in the print result.
</li>
</ul>

The <code>importname</code> in the full form import declaration can be a dot
(<code>.</code>). Such imports are called dot imports.
For dot imports, the prefix part <code>pkg.</code> must be omitted in qualified identifiers,
which makes it look the exported resources declared in the imported packages
are declared in the importing package.

<pre class="line-numbers"><code class="language-go">package main

import (
	. "fmt"
	. "time"
)

func main() {
	Print("Go 1.0 was release at year 2012, ")
	Println("about", Now().Year() - 2012, "years ago.")
}
</code></pre>

<p>
<code>Year</code> is a method of type <code>time.Time</code>.
It will return the year of a time, as an <code>int</code> value.
</p>

<p>
Generally, dot imports are not recommended to use in formal projects.
</p>

<p>
The <code>importname</code> in the full form import declaration can be blank identifier
(<code>_</code>). Such imports are called anonymous imports.
The importing source files can't use the exported resources in anonymously imported packages.
The purpose of anonymous imports is to initialize the imported packages
(each of <code>init</code> functions in the anonymously imported packages will be called once).
</p>

For example, the following <code>mysql</code> package will register
the MySQL driver in one of its <code>init</code> functions.
The driver will be registered into a global map table in
the standard <code>database/sql</code> packge.
We will not use the resources in the third-party <code>mysql</code> package.
<pre class="line-numbers"><code class="language-go">package main

import (
	"database/sql"
	_ "github.com/go-sql-driver/mysql"
)

func main() {
	db, err := sql.Open("mysql", "user:password@/dbname")
	...
}
</code></pre>

<p>
BTW, we can run <code>go get github.com/go-sql-driver/mysql</code> to
download the <code>mysql</code> package into the <code>src</code> folder
under the first path specified in the <code>GOPATH</code> environment variable.
<code>go get</code> needs the corresponding version control tool has been installed.
For this case, <code>git</code> must be installed.
</p>

<p>
Except anonymous imports, the official Go compiler requires
any of other imports must be used at once.
</p>
</div>

<h3>Functions And Operators</h3>

<div>
<p>
Simply speaking, 
programming can be viewed as manipulating all kinds of operations
by compositing them with all kinds of ways.
Each operation, in its active period,
will read some data and signals from all kinds of devices from time to time,
and write some data and signals to all kinds of devices from time to time.
</p>

<p>
An operation must clearly know the formats of the data it gets, modifies and returns.
Most programing languages use types as data formats and values as data.
<a href="type-system-overview.html">This article</a> makes an overview on Go types.
</p>

<p>
In popular programing languages, most common operations are achieved by
calling functions and using operators.
</p>

<p>
The above sections have shown some simple function usages. The article
<a href="function.html">functions in Go</a> will make details explainations for Go functions.
So here, following will only show two simple function declarations and how to call them.
</p>

A simple example which shows a function declaration and a function call.
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

// A function declaration. This function has two
// input parameters and three return results.
func AddSubCompare(a, b int) (int, int, bool) {
	return a+b, a-b, a==b
}

// Return results can have names.
func Double(x float64) (y float64) {
	y = x+x
	return
}

func main() {
	// Call the above two functions.
	fmt.Println(AddSubCompare(5, 3)) // 8 2 false
	fmt.Println(Double(2.9)) // 5.8
}
</code></pre>

<p>
Followings in this section are to explain common operators in Go.
</p>

<p>
The explainations for operators in this article don't stick to academic strictness,
and emphasize more on the differences from other programming languages.
</p>

<p>
For the operators listed in the following table,
the types of the two operands must be the same unless clarified specially.
All unary operators listed in the following table are prefix operators.
And each of the binary operators listed in the following table will
show up between its two operands in code.
</p>

<table class="table table-bordered text-center" style="width: auto !important;">
<thead>
	<tr>
	<th class="text-center" style="white-space: nowrap;">Operator</th>
	<th class="text-center">Name</th>
	<th class="text-center">Requirements For Operands</th>
	<th class="text-center">Type Of The Result Value</th>
	</tr>
</thead>
<tbody>
	<tr class="active">
		<th scope="row" class="text-center" style="white-space: nowrap;">+ (binary)</th>
		<td>
			addition (for numeric operands)<br/>
			concatenation (for string operands)
		</td>
		<td style="vertical-align: middle;">
			must be values of
			integer types,
			floating-point types,
			complex types or
			string types
		</td>
		<td rowspan="7" style="vertical-align: middle;">the same as the operand(s)</td>
	</tr>
	<tr class="active">
		<th scope="row" class="text-center" style="white-space: nowrap;">- (binary)</th>
		<td>subtraction</td>
		<td rowspan="5" style="vertical-align: middle;">must be values of numeric types</td>
	</tr>
	<tr class="active">
		<th scope="row" class="text-center" style="white-space: nowrap;">+ (unary)</th>
		<td>positive</td>
	</tr>
	<tr class="active">
		<th scope="row" class="text-center" style="white-space: nowrap;">- (unary)</th>
		<td>negative</td>
	</tr>
	<tr class="active">
		<th scope="row" class="text-center" style="white-space: nowrap;">* (binary)</th>
		<td>multiplication</td>
	</tr>
	<tr class="active">
		<th scope="row" class="text-center" style="white-space: nowrap;">/ (binary)</th>
		<td>division</td>
	</tr>
	<tr class="active">
		<th scope="row" class="text-center" style="white-space: nowrap;">% (binary)</th>
		<td>remainder</td>
		<td>must be values of interger types</td>
	</tr>

	<tr>
		<th scope="row" class="text-center" style="white-space: nowrap;">&lt;&lt; (binary)</th>
		<td>bitwise left shift</td>
		<td rowspan="2" style="vertical-align: middle;">
			left operand must be an integer and
			right operand must be an unsigned interger
		</td>
		<td rowspan="2" style="vertical-align: middle;">the same as the left operand</td>
	</tr>
	<tr>
		<th scope="row" class="text-center" style="white-space: nowrap;">&gt;&gt; (binary)</th>
		<td>bitwise right shift</td>
	</tr>
	<tr>
		<th scope="row" class="text-center" style="white-space: nowrap;">&amp; (binary)</th>
		<td>bitwise and</td>
		<td rowspan="5" style="vertical-align: middle;">must be values of integer types</td>
		<td rowspan="5" style="vertical-align: middle;">the same as the operand(s)</td>
	</tr>
	<tr>
		<th scope="row" class="text-center" style="white-space: nowrap;">| (binary)</th>
		<td>bitwise or</td>
	</tr>
	<tr>
		<th scope="row" class="text-center" style="white-space: nowrap;">^ (binary)</th>
		<td>bitwise xor</td>
	</tr>
	<tr>
		<th scope="row" class="text-center" style="white-space: nowrap;">&amp;^ (binary)</th>
		<td>bitwise clear</td>
	</tr>
	<tr>
		<th scope="row" class="text-center" style="white-space: nowrap;">^ (unary)</th>
		<td>bitwise not</td>
	</tr>

	<tr class="active">
		<th scope="row" class="text-center" style="white-space: nowrap;">&amp;&amp; (binary)</th>
		<td>boolean and</td>
		<td rowspan="3" style="vertical-align: middle;">must be values of boolean types</td>
		<td rowspan="3" style="vertical-align: middle;">the same as the operand(s)</td>
	</tr>
	<tr class="active">
		<th scope="row" class="text-center" style="white-space: nowrap;">|| (binary)</th>
		<td>boolean or</td>
	</tr>
	<tr class="active">
		<th scope="row" class="text-center" style="white-space: nowrap;">! (unary)</th>
		<td>boolean not</td>
	</tr>
	
	<tr>
		<th scope="row" class="text-center" style="white-space: nowrap;">== (binary)</th>
		<td>equal to</td>
		<td rowspan="2" style="vertical-align: middle;">
			generally, both operands should be comparable values
			(please read the <a href="conversions-assignments-and-comparisons.html">value
			comparison rules in Go</a> for details)
		</td>
		<td rowspan="6" style="vertical-align: middle;">untype boolean type</td>
	</tr>
	<tr>
		<th scope="row" class="text-center" style="white-space: nowrap;">!= (binary)</th>
		<td>not equal to</td>
	</tr>
	<tr>
		<th scope="row" class="text-center" style="white-space: nowrap;">&lt; (binary)</th>
		<td>less than</td>
		<td rowspan="4" style="vertical-align: middle;">
			must be values of
			integer types,
			floating-point types or
			string types
		</td>
	</tr>
	<tr>
		<th scope="row" class="text-center" style="white-space: nowrap;">&lt;= (binary)</th>
		<td>less than or equal to</td>
	</tr>
	<tr>
		<th scope="row" class="text-center" style="white-space: nowrap;">&gt; (binary)</th>
		<td>larger than</td>
	</tr>
	<tr>
		<th scope="row" class="text-center" style="white-space: nowrap;">&gt;= (binary)</th>
		<td>larger than or equal to</td>
	</tr>
</tbody>
</table>

Note,
<ul>
<li>
	the addition binary operator <code>+</code> can also be used as a positive unary operator.
	<code>+n</code> is equivalent to <code>0 + n</code>.
</li>
<li>
	the subtraction binary operator <code>-</code> can also be used as a negative unary operator.
	<code>-n</code> is equivalent to <code>0 - n</code>.
</li>
<li>
	the <i>bitwise xor</i> binary operator <code>^</code>
	can also be used as a <i>bitwise not</i> unary operator.
	<code>^n</code> is equivalent to <code>(-1) ^ n</code>.
	<i>Bitwise not</i> operator is also called <i>bitwise complement</i> operator.
	In many other languages, <i>bitwise not</i> is represented with <code>~</code>.
</li>
<li>
	the bitwise clear operator <code>&amp;^</code> is a unique operator in Go.
	<code>m &amp;^ n</code> is equivalent to <code>m &amp; (^n)</code>.
</li>
<li>
	unlike Java, Go supports unsigned integer types,
	so the unsigned shift operator <code>&gt;&gt;&gt;</code> doesn't exist in Go.
</li>
<li>
	there is no power operator in Go, please use <code>math.Pow</code> funtion instead.
</li>
</ul>

<p>
The operator precedences may be also some different to other languages.
Here are the operator precedences in Go. Top ones have higher precedences.
The precedences of operators in the same line are same.
Like many other languages, <code>()</code> can be used to promote precedences.
</p>

<pre class="line-numbers"><code class="language-go">*   /   %   <<  >>  &   &^
+   -   |   ^
==  !=  <   <=  >   >=
&&
||
</code></pre>

An example of using all kinds of operators:
<pre class="line-numbers"><code class="language-go">package main

...
</code></pre>

<p>
Same as C/C++,
there are two pointer related operators, <code>*</code> and <code>&amp;</code>.
Yes the same operator symbols as the multiplication and bitwise and operators.
<code>&amp;</code> is used to take the address of an addressable value,
and <code>*</code> is used to deference a pointer value.
Unlike C/C++, in Go, values of pointer types don't support arithmetic operations.
For more details, please read <a href="pointer.html">pointers in Go</a>.
</p>

<p>
There are some other operators in Go.
They will be introduced and explained at the proper time.
</p>

</div>

<h3>Expressions, Statements And Simple Statements</h3>

<p>
The Go 101 articles will not make definitions for
the concepts of expressions, statements and simple statements from the academic view.
Only some exasmple will be provided to show their differences.
</p>

<p>
Each expression involves several operands.
Generally, an expression has one single return result (there are a few exceptions),
so the expression can be used as an operand in another expression.
However, a statement can't be used as an operand in other expressions.
</p>

<p>
Any solo value, including literals and the soon to be introduced variables and constants, can be viewed as expressions.
In fact, an expression with one single return result can often be called a value.
</p>

<p>
Simple statements are special statements.
Simple statement is a special concept in Go to make code look simple and clean.
<b>In Go code, some portions of all kinds of control flow blocks
can only be simple statements.</b>
</p>

<p>
All the operations by using the operators mentioned in the last sections are expressions.
</p>

<p>
Like C++, Go also supports <code>x++</code> and <code>x--</code>,
but doesn't support <code>++x</code> and <code>--x</code>.
<code>x++</code> and <code>x--</code> are expressions in C++,
but bhey are both simple statements in Go.
In other words, they can't be used in other expressions.
</p>

<p>
Like many other languages, there are <code>op=</code> operators
where <code>op</code> can be an arithmetic operator or a bitwise operator.
Operations using such <code>op=</code> operators have no return values,
so they are not expressions. They are simple statements.
</p>

<p>
More simple statements and non-simple statements
will be pointed out when they are encountered later.
</p>

<h3>Variables, Variable Declarations And Value Assigments</h3>

<p>
Variables can be viewed as named and addressable values,
which means a variable can always be taken address.
Addressable values can be modified at run time.
</p>

<p><i>
(Note, the definition of variables in Go 101 article series is not totally the same as
<a href="https://golang.org/ref/spec#Variables">Go specification</a>.)
</i></p>

<div>
Variables must be declared before being used.
There are two basic variable declaration forms.
Please read the comments in the following program to learn
how to declared variables in Go programming:
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	// This is the full standard form of variable declaration.
	// A variable named "website" is declared and inialized.
	// Its type is "string", which is a buint-in type.
	// "var" is a keyword used to declare variables.
	var website string = "https://golang.org"
	
	// Declare a variable without type specified.
	// Compiler will deduce/infer its type as "string".
	var name = "Go"
	
	// Declare a variable without explicitly initalizing it.
	// Its inital value is the zero value (false) of its
	// type "bool".
	var currentVersion string
	
	// Multiple variables can be decalred at the same line.
	var bornYear, bornMonth, bornDay int

	// If the types of the variables declared at the same
	// line are not all the same, then their types mustn't
	// be present in the declaration, and they must be
	// initialized in the declartion.
	var announceYear, static, compiled = 2007, true, true
	
	/*
	All above variable declarations are called standard
	variable declaration. In standard variable declarations,
	all variables at the left of the assignment sign "="
	must be new ones.
	*/
	
	// This is an assignment. Multiple values can be
	// modified at the same code line. All variables at the
	// left of the assignment sign "=" in an assignment must
	// be ever declared.
	bornYear, bornMonth, bornDay = 2009, 11, 10

	// We can exchange the values of two variables within
	// one code line in Go.
	// bornYear is 2007 and announceYear is 2009.
	bornYear, announceYear = announceYear, bornYear
	
	// The following is a short variable declaration form.
	// The "var" keyword and variable types must be omitted
	// in short delcaration forms. And the assignment sign
	// must be ":=" instead of "=".
	name, numKeywords := "Go", 25

	/*
	There are two requirements for short variable
	declaration forms:
	1. All items at the left of the assignment sign must 
	   be identifiers.
	2. There must be at least one new variable at the left
	   of the assignment sign.
	
	In the abov short variable declaration, the "name"
	variable is old variable whih has been declared earlier
	and the "numKeywords" variable is a new one. So here
	the "name" variable is modified but the "numKeywords"
	variable is declared and initialized.
	*/
	
	// Use some of the declared variables above.
	fmt.Println(name, "born at year", bornYear)
	fmt.Println(name, "announced at year", announceYear)
	// releaseAt is a package-level variable declared below.
	fmt.Println(name, "1.0 released at year",  releaseAt)
	
	// In Go, local declared variables must be used,
	// otherwise, compiler will report errors for
	// unused declared local variables.
	// We can assign the unused variables to the
	// blank identifier to make them used.
	_, _, _ = static, compiled, currentVersion
	_, _, _, _ = website, numKeywords, bornMonth, bornDay
}

// Above declared variables are called local variables, which
// are declared in function bodies, directly or indirectly.
// Variables can be declared outside of any function bodies.
// Such variables are calld package-level variables.
// Package-level variables are often called global variable.

// Package-level variables must be declared with standard
// variable declaration form.
var createdBy, releaseAt = "Google Research", 2012

// Unlike local variables, package-level variables can be
// decalred but never used. Here the "createdBy" variable
// is never used in thi program. This is allowed.
</code></pre>

Run it:
<pre class="output">
Go born at year 2007
Go announced at year 2009
Go 1.0 released at year 2012
</pre>

<p>
Please note, <b>value assignments and short variable declarations are simple statements,
but standard variable declarations are not</b>.
</p>

<p>
The type inference feature lets us not have to specify the types of variables
when declaring the variables. This makes Go programming very convennient and
makes Go code look very clean.
</p>

<p>
As type names are not keywords, variables can be named as type names.
However, generally doing this is not recommended.
</p>

Like package imports,
multiple variables can group into one standard form declaration by using <code>()</code>.
For example, the following variable declarations
<pre class="line-numbers"><code class="language-go">var a, b bool
var m int = 123
var x, y = 3.2, 5.6
</code></pre>

can be rewritten to
<pre class="line-numbers"><code class="language-go">var (
	a, b bool
	m int = 123
	x, y = 3.2, 5.6
)
</code></pre>
<p>
Generally, declaring related variables together will get a better readability.
</p>

<p>
There is another variant of the standard variable declaration form,
which is used for declaring struct member variables (fields)
and function input and output variables (parameters and results).
Here will not make an introduction for this form.
</p>

<p>
Like many other languages, variables (and other kinds of identifiers) each has a scope.
A variable may be shadowed by another same name variable which is declared in an inner
code block within the scope of the first variable.
Please <a href="block-and-scope.html">blocks and scopes in Go</a> for details.
</p>


</div>

<h3>Constant Declaration</h3>

<p>
Constants can be viewed named literal values.
Each constant in Go represents a literal value.
In Go, constants can only be boolean, numeric and string values.
</p>

<p>
At compile time, Go compile will replace each constant with the literal it represents.
Constant values will not exist at run time, so they are not addressable.
</p>

<div>
Same as variables, constants must be declared before being used.
Constants are declared with the <code>const</code> keyword.
Here are some constant declaration examples:
<pre class="line-numbers"><code class="language-go">package main

import	"fmt"

// Declare a single constant.
// Yes, non-ASCII letter can be used in identifiers.
const π = 3.1416

// Decalre multiple constants in one same code line.
const phi_double, phi_half = π * 2, π * 0.5

// Declare multiple constants as a group. Same as package
// imports and variable declarations, multiple constants
// can be declared together in one declaration by using ().
const (
	Yes        = true
	MaxDegrees = 360
	Unit       = "radian"
)

// constant can also be declared in function bodies.

func main() {
	
	// In this declaration, an incomplete line will
	// be auto-completed by copying the corresponding
	// missing part from the previous line.
	const (
		x = "Go" + "lang"
		y
		z
	)
	
	fmt.Println(x, y, z) // Golang Golang Golang

	// "iota" is a special predecalred constant.
	// In a multi-constant declaration, the value
	// of "iota" will start from 0 and increase one
	// line by line in the const declareation body.
	const (
		k = 3                // now iota == 0
		m = iota + iota      // <=> 1 + 1
		n                    // <=> 2 + 2
		_                    // <=> 3 + 3
		p = 9                //
		q = iota * 2         // <=> 5 * 2
		_                    // <=> 6 * 2
		s = "abc"            // 
		t = len([iota]int{}) // <=> len([8]int)
	)
	// Please note, the name of third constant in the
	// last declaration is the blank identifer.
	
	fmt.Println(k, m, n, p, q, t) // 3 2 4 9 10 8
	
	// All below declared constants are 0, for they
	// are declared in seperated declaration bodies.
	const a, b = iota, iota
	const c    = iota
	const d    = iota
	
	fmt.Println(a, b, c, d) // 0 0 0 0
}
</code></pre>

<p><i>
(Note 1: here, <code>[7]int{}</code> is an array value.
Arrays, and other container types, will be explained in article
<a href="container.html">containers in Go</a>.)
</i></p>

<p><i>
(Note 2: under <a href="summaries.html#compile-time-evaluation">specific circumstances</a>,
the built-in <code>len</code> function will be evaluated at compile time.
The values assigned to constants must be evaluated at compile time.)
</i></p>

<p>
Constants can be assigned to variables, but not vice versa.
</p>

<p>
You may have found that, none of the declared constants is specified a type.
Such constants are called untyped constants.
In fact, a constant can be specified a type when it is declared.
Such constants are called typed constants.
</p>

<p>
Generally, it is highly not recommended to declare typed constants.
The reason is that, each typed constant has only one possible type (the one specified for it),
but each untyped constant has one default type and several potential types.
This difference gives untyped constants some advantages when
they are used as the source values in value assignments.
In Go, if the source value in a value assignment is a constant
and the destination value is not an interface value,
then the type of the destination value must be one of the possible types
of the destination value.
So untyped constants can be assigned to values of more different types.
</p>

Here is an example showing the difference.
<pre class="line-numbers"><code class="language-go">package main
</code></pre>

An untyped integer constant value can represent a very large value
which is impossible to be stored in any integer variable at run time.
<pre class="line-numbers"><code class="language-go">package main
</code></pre>

</div>

<h3>Conversions, Assignments And Comparisons</h3>

type inference in variable decl + assign typed source value

todo:

<h3>Basic Control Flows</h3>

<p>
The control flow blocks in Go are much like other popular programming languages,
but there are many differences.
This section will show these similarities and differences.
</p>

<div>
There are three kinds of basic control flow code blocks in Go:
<ul>
<li>
	<code>for</code> loop block.
</li>
<li>
	<code>if-else</code> two-way conditional execution block.
</li>
<li>
	<code>switch-case</code> multi-way conditional execution block.
</li>
</ul>

<p>
The basic control flow code blocks are much similar to the ones in many other popular languages,
but there are also many differences.
</p>

There are also some control flow code blocks which are related to certain kinds of types in Go.
<ul>
<li>
	<code>for-range</code> loop block for container types.
</li>
<li>
	<code>type-switch</code> multi-way conditional execution block for interface types.
</li>
<li>
	<code>select-case</code> block for channel types.
</li>
</ul>

<p>
Like many ohter popular languages, Go also supports <code>break</code>,
<code>continue</code> and <code>goto</code> code jump statements.
Beside these, there is a special code jump statement, <code>fallthrough</code>, in Go.
These statements are not simple statements.
</p>

<p>
There are some other kind of flow control ways,
such as <a href="defer.html">deferred function calls</a>
and <a href="panic-recover-mechanism.html">panic/recover mechanism</a>.
<a href="goroutine.htl">Goroutines</a> can also be viewed as a way of flow control.
</p>

<p>
Only the basic control flow code blocks and code jump statements will be explained
in the current article, other ones will be explained in many other articles in Go 101 series.
</p>
</div>

<h4><code>if-else</code> Control Flow Blocks</h4>

<div>
The full form of a <code>if-else</code> code block is
<pre class="line-numbers"><code class="language-go">if InitSimpleStatement; Condition {
	...
} else {
	...
}
</code></pre>
<p>
Like many other programming languages, the <code>else</code> block is optional.
</p>
<p>
The <code>InitSimpleStatement</code> part is also optional.
It must a simple statement, so it can be a short variable declaration form
or a value assignment, but can't be a standard variable declaration form.
<code>Condition</code> must be an expression which result is a boolean value.
The two parts following a <code>if</code> keyword can't be enclosed in <code>()</code>.
</p>

<p>
If the <code>InitSimpleStatement</code> in a <code>if-else</code> code block is present,
it will be executed before executing other statements in the <code>if-else</code> code block.
</p>

Example:
<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano())
	x := rand.Int()
	
	if n := x % 2; n == 0 {
		fmt.Println(x, "is an even number.")
	} else {
		fmt.Println(x, "is an odd number.")
	}
	
	if x % 2 == 0 {
		fmt.Println(x, "is an even number.")
	} else {
		fmt.Println(x, "is an odd number.")
	}
	
	if n := x % 2; n == 0 {
		fmt.Println(x, "is an even number.")
	}
	
	if x % 2 == 0 {
		fmt.Println(x, "is an even number.")
	}
}
</code></pre>

todo: two or three scopes.
</div>

<h4><code>for</code> Loop Control Flow Blocks</h4>

<div>
The full form of a <code>for</code> loop code block is
<pre class="line-numbers"><code class="language-go">for InitSimpleStatement; Condition; PostSimpleStatement {
	...
}
</code></pre>
<p>
There are three parts following the <code>for</code> keyword.
The <code>InitSimpleStatement</code> and <code>PostSimpleStatement</code> parts
must be simple statements, and the <code>PostSimpleStatement</code> part
mustn't be a short variable declaration.
This means the <code>InitSimpleStatement</code> part can be a short variable declaration
form or a value assignment, but can't be a standard variable declaration form.
<code>Condition</code> must be an expression which result is a boolean value.
</p>

<p>
If the <code>InitSimpleStatement</code> in a <code>for</code> loop code block is present,
it will be executed only once before executing other statements in the <code>for</code> loop code block.
</p>

<p>
The <code>Condition</code> expression will be evaluated at each loop step.
If the evaluation result is <code>false</code>, then the loop will end.
Otherwise the body of the loop will get executed.
</p>

<p>
The <code>PostSimpleStatement</code> will be executed at the end of each loop step.
</p>

<p>
Unlike many other programming languages, the three parts following the <code>for</code>
keyword can't be enclosed in <code>()</code>.
</p>

A <code>for</code> loop example. The example will print the integers from
<code>0</code> to <code>9</code>, each on one line.
<pre class="line-numbers"><code class="language-go">for i := 0; i < 10; i++ {
	fmt.Println(i)
}
</code></pre>

The <code>InitSimpleStatement</code> and <code>PostSimpleStatement</code> parts
can be omitted. The form is can be called as condition-only <code>for</code> loop form.
It is the same as the <code>while</code> loop in other languages.
<pre class="line-numbers"><code class="language-go">var i = 0
for i < 10 {
	fmt.Println(i)
	i++
}
</code></pre>

The <code>Condition</code> part can also be omiited.
Like the <code>if</code> code block,
when the <code>Condition</code> part in a <code>for</code> loop is omitted,
Go compile will think the condition is <code>true</code>.
<pre class="line-numbers"><code class="language-go">for i := 0; ; i++ {
	fmt.Println(i)
	if i >= 10 {
		break
	}
}
</code></pre>
<p>
Note, here a <code>break</code> statement is used to make execution jump out of the
<code>for</code> loop block.
The <code>break</code> statement can be
used to jump out of the five kinds of code blocks mentioned above
(the once exception is the <code>if-else</code> block).
Only the innermost code block ( of the five kinds) which enclossed
the <code>break</code> statement will be jumped out of.
A <code>break</code> keyword can be followed by a label,
so that it can make execution jump out of any code block (of the five kinds)
which enclosed the <code>break</code> statement.
Below will explain labels in detail.
</p>

In fact, all the three parts following the <code>for</code> keyword can be omitted.
The form is can be called as bare <code>for</code> loop form.
It is the same as the <code>while(true)</code> loop in other languages.
<pre class="line-numbers"><code class="language-go">var i = 0
for {
	fmt.Println(i)
	i++
	if i >= 10 {
		break
	}
}
</code></pre>

For the full <code>for</code> loop form,
any of the three parts following the <code>for</code> keyword can be blank
(but the two <code>;</code> are still present).
<pre class="line-numbers"><code class="language-go">package main

func main() {
	var i int
	for i = 0; ; {
		break
	}
	
	for ; i < 10 ; {
		break
	}
	
	for ; ; i++ {
		break
	}
	
	for ; ;  {
		break
	}
}
</code></pre>

<p>
The last code block in the above example is equivalent to the bare <code>for</code> loop.
</p>

A <code>continue</code> statement can be used in a <code>for</code> loop block
to end the current loop step earlier and start the next loop step.
Here is an example to print all even integers under <code>10</code>.
<pre class="line-numbers"><code class="language-go">for i := 0; i < 10; i++ {
	if i%2 == 1 {
		continue
	}
	fmt.Println(i)
}
</code></pre>

todo: two scopes

</div>

<h4><code>switch-case</code> Control Flow Blocks</h4>

<div>
The full form of the <code>switch-case</code> code block is some hard to describe clearly,
so here just shows an example to demo the full form:
<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
	"math/rand"
	"time"
)

func init() {
	rand.Seed(time.Now().UnixNano())
}

func main() {
	switch n := rand.Intn(100); n%9 {
	case 0:
		fmt.Println(n, "is a multiple of 9.")

		// Different from many other languages, in Go, the 
		// execution will automatically jumps out of the
		// switch-case block at the end of each branch block.
		// No "break" statement is needed here.
	case 1, 2, 3:
		fmt.Println(n, "mod 9 is 1, 2 or 3.")
	case 4, 5:
		fmt.Println(n, "mod 9 is 4 or 5.")
	default:
		fmt.Println(n, "mod 9 is 6, 7, or 8.")
	}
}
</code></pre>

<p>
In the abvoe example, <code>switch</code>, <code>case</code> and <code>default</code> are all keywords.
The <code>default</code> and <code>case</code> keywords each corresponds a nested branch code block.
</p>

<p>
There mustn't be expressions following the <code>default</code> keyword,
but there must be one expression following each <code>case</code> keyword.
</p>

The values following <code>case</code> keywords can be constants, literals, variables, or any other expressions.
Among all the boolean, numeric and string literals (including constants) following
all <code>case</code> keywords in a <code>switch-case</code> code block, there mustn't be two duplicated ones.
For example, the following code block is illegal, for the literal <cod>3</cod> follows two <code>case</code> keywords.
<pre class="line-numbers"><code class="language-go">switch n := rand.Intn(100); n%9 {
case 0:
	fmt.Println(n, "is a multiple of 9.")
case 1, 2, 3:
	fmt.Println(n, "mod 9 is 1, 2 or 3.")
case 3, 4, 5:
	fmt.Println(n, "mod 9 is 4 or 5.")
default:
	fmt.Println(n, "mod 9 is 6, 7, or 8.")
}
</code></pre>

There can be two parts following the <code>switch</code> keyword
in a <code>switch-case</code> code block, both are optional.
Like <code>if-else</code> and <code>for</code> loop code blocks,
the first part must be a simple statement and it will be executed before
other statements in the <code>switch-case</code> code block if it is present.
The second part must an expression which result should be a typed value.
<ul>
<li>
	If the second part is absent, Go compile will viewed it as typed
	<code>bool</code> value <code>true</code>.
</li>
<li>
	If the second part (an expression) is present and its result is an untyped value,
	then it must have a default type,
	so that Go compiler will view it as a typed value which type is the default type.
	For this reason, the second part can't be an untyped <code>nil</code>
	(which has not a default type).
</li>
<li>
	At run time, the typed value will be compared with the values following each <code>case</code> keyword,
	from top to bottom. If one value following a <code>case</code> keyword is equal to the typed value,
	then the corresponding nested branch code block of the <code>case</code> keyword will be executed.
</li>
</ul>

The <code>default</code> branch is optional, the same for any <code>case</code> branch.
So the following code blocks are all legal, but they are all no-ops.
<pre class="line-numbers"><code class="language-go">switch n := 5; n {
}

switch 5 {
}

switch {
}
</code></pre>

How to make the execution slip into the next branch?
There is a <code>fallthrough</code> keyword in Go to achieve this.
For example:
<pre class="line-numbers"><code class="language-go">switch n := rand.Intn(100); n%9 {
case 0:
	fmt.Println(n, "is a multiple of 9.")
case 1:
	fmt.Println(n, "mod 9 is 1.")
	fallthrough
case 2:
	fmt.Println(n, "mod 9 is 1 or 2.")
	fallthrough
case 3:
	fmt.Println(n, "mod 9 is 1, 2 or 3.")
}
</code></pre>

Please note, a <code>fallthrough</code> statement must be the final statement in a branch.
For example, the following <code>fallthrough</code> usages are both illegal.
<pre class="line-numbers"><code class="language-go">switch n := rand.Intn(100); n%9 {
case 0:
	fmt.Println(n, "is a multiple of 9.")
case 1:
	if true {
		fallthrough // fails to compile
	}
case 2:
	fallthrough // fails to compile
	fmt.Println(n, "mod 9 is 1 or 2.")
case 3:
	fmt.Println(n, "mod 9 is 1, 2 or 3.")
}
</code></pre>

<p>
The <code>fallthrough</code> statement can't show up in the final branch in a <code>switch-case</code> code block.
</p>

<p>
The <code>break</code> statement can also be used in any branch block of a <code>switch-case</code>
code block to make code execution jump out of the <code>switch-case</code> code block earlier.
Here will not show examples of using <code>break</code> statements in <code>switch-case</code> code blocks.
</p>

Another obvious differences from many other languages is the order of the <code>default</code> branch
in a <code>switch-case</code> code block can be arbitrary.
Example:
<pre class="line-numbers"><code class="language-go">func main() {
	// In the following code blocks, the second parts
	// following the "switch" keywords are all absent,
	// compile will view them as true (of type "bool").
	
	switch n := rand.Intn(3); {
	case n == 0: fmt.Println("n == 0")
	case n == 1: fmt.Println("n == 1")
	default: fmt.Println("n == 2")
	}
	
	switch n := rand.Intn(3); {
	default: fmt.Println("n == 2")
	case n == 0: fmt.Println("n == 0")
	case n == 1: fmt.Println("n == 1")
	}
	
	switch n := rand.Intn(3); {
	case n == 0: fmt.Println("n == 0")
	default: fmt.Println("n == 2")
	case n == 1: fmt.Println("n == 1")
	}
}
</code></pre>
</div>

<h4><code>goto</code> Statement And Label Declaration</h4>

<p>
Like many other languages, Go also supports <code>goto</code> statement.
A <code>goto</code> keyword must be followed a label to form a statement.
A label must be declared to be used. Labels must be declared in function bodies.
The innermost function body containing a label use must be the same as
the innermost function body containing the declaration of the label.
In other words, labels can't be used crossing function bodies.
</p>

<p>
A <code>goto</code> statement will make the execution jump to the next statement
following the declaration of the label used in the <code>goto</code> statement.
</p>

<div>
The declaration of a label may appear before or after its uses.
A label is declared with the form <code>LabelName:</code>,
where <code>LabelName</code> must be an identifier.
<pre class="line-numbers"><code class="language-go">func main() 

</code></pre>

Note, if a label is declared before the declaration of a variable,
then the uses of the label must be out of the scope of the variable.
The following code will fail to compile.
<pre class="line-numbers"><code class="language-go">func main() 

</code></pre>

To make the above code compile okay, the scope of the variable must be shrinked
by creating a new code block with <code>()</code>.
<pre class="line-numbers"><code class="language-go">func main() 

</code></pre>

<p>
With the new code block, the scope of the variable is from the end of its declaration
to the end of the new code block, instead of the end of the <code>main</code> function.
</p>

<p>
You can read <a href="block-and-scope.html">blocks and scopes in Go</a>
to get more information about code blocks and identifier scopes.
</p>
</div>

<h4><code>break</code> Statements With Labels</h4>

<div>
A <code>break</code> keyword can be followed a label or not.
A label following a <code>break</code> keyword must be declared just before
a code block of the five kinds of code blocks:
<ul>
<li>
	<code>for</code> loop block.
</li>
<li>
	<code>for-range</code> loop block.
</li>
<li>
	<code>swtich-case</code> loop block.
</li>
<li>
	<code>type-switch</code> loop block.
</li>
<li>
	<code>select-case</code> loop block.
</li>
</ul>

<p>
The name of the label declared just before such a code block
can be viewed as the name of this code block.
In other words, we can use the label name to identify this code block.
</p>

<p>
The <code>break</code> keywords followed with a label must be within
the code block identified by the label.
Such <code>break</code> statements will make the execution jump out of
the code block identified by the label.

A <code>break</code> statement without a label will make the execution
jump out of the innermost control flow code block (of the just listed five kinds)
containing the <code>break</code> statement.
</p>

Generally, <code>break</code> statements with labels are used in inner nested code blocks,
to jump out of an outer nesting code block.
<pre class="line-numbers"><code class="language-go">func main() 

</code></pre>
</div>

<p>
A declared label must be used at lease once,
except the identifier of the label is the blank identifer <code>_</code>.
</p>

<h4><code>continue</code> Statements With Labels</h4>

<div>
<p>
Each <code>continue</code> keyword can also be followed a label or not.
A label following a <code>continue</code> keyword must be declared just before
a <code>for</code> loop or a <code>for-range</code> loop code block.
</p>

<p>
The <code>continue</code> keyword followed with a label must be within
the loop code block identified by the label.
Such a <code>continue</code> statement will end the current loop step
of the loop code block identified by the label (and start the next loop step).

A <code>continue</code> statement without a label will end the current loop step
of the innermost loop code block containing the <code>continue</code> statement.
</p>

Generally, <code>continue</code> statements with labels are used in inner nested loop code blocks,
to end the current loop step of an outer nesting loop code block.
<pre class="line-numbers"><code class="language-go">func main() 

</code></pre>
</div>

<p class="anchor" id="line-break-rule"></p>
<h3>Line Break Rules</h3>

<div>
<p>
You should have found that semicolons (<code>;</code>) are seldom used in Go code.
They only appear in some control flow blocks shown above.
In fact, many code lines can end with semicolons.
It is just that these semicolon are optional and
it is idiomatic to omit these semicolons in Go programming.
</p>

Go compilers will insert the missing semicolons for you at compile phase, either vitually or really.
Here is the insertion rules listed in
<a href="https://golang.org/ref/spec#Semicolons">Go specification</a>:
<ol>
<li>
	When the input is broken into tokens,
	a semicolon is automatically inserted into the token stream immediately
	after a line's final token if that token is
	<ul>
	<li>
		an identifier
	</li>
	<li>
		an integer, floating-point, imaginary, rune, or string literal
	</li>
	<li>
		one of the keywords <code>break</code>, <code>continue</code>,
		<code>fallthrough</code>, or <code>return</code>
	</li>
	<li>
		one of the operators and punctuation
		<code>++</code>, <code>--</code>,
		<code>)</code>, <code>]</code>, or <code>}</code>
	</li>
	</ul>
</li>
<li>
	To allow complex statements to occupy a single line,
	a semicolon may be omitted before a closing ")" or "}".
</li>
</ol>

In other words, <code>;</code> can be ignored for many situations.
Certainly, we can choose to put multiple statements in one code line.
For such situations, the <code>;</code> between two statements can't be ignored.
<pre class="line-numbers"><code class="language-go">var a = 1; var b = true
a++; b = !b
print(a); print(b)
</code></pre>

The rules don't directly define which positions code lines can be broken at.
They do mention which positions code lines can't be broken at.
For example, here are some cases code lines are broken at inappropriate positions.
<pre class="line-numbers"><code class="language-go">func main() 

</code></pre>

Go compiler will insert some semicolons, so the above code
is equivalent to the following one
<pre class="line-numbers"><code class="language-go">func main() 

</code></pre>

<p>
Obviously, the code will fail to compile.
</p>

If you do need to break a long code line, here is a simple rule to do it.
The simple rule is not equivalent to but it also doesn't
collide with the above mentioned official rules.

<div class="alert alert-success">
A code line should be broken just after a binary operator
or any of <code>{[(,:=</code> (six symbol letters).
</div>

todo: "," following the last value in a sequence literal.
</div>


<!---
Common standard libraries introduction.
-->