<h1>Panic And Recover</h1>

<p>
Go doesn't support exception throwing, instead,
explicit error handling is preferred in Go programming.
</p>

<p>
In fact, Go supports an exception throw/catch alike mechanism.
The mechanism is called panic and recover.
This article will show how to use this mechanism.
</p>

<h3>Panic</h3>

<p>
We can make a goroutine become panicking by calling the built-in
<code>panic</code> function to create a panic in the gorotuine.
If a goroutine is panicking, only the deferred function calls
will get executed, in the reverse order they were deferred.
</p>

<p>
A panic can be recovered to make the corresponding panicking goorutine restore to normal.
Please read the next section for details.
</p>

<p>
Creating a panic is one way for a function to return.
After the return and before the exit of the function,
the function calls alreay been deferred in the function will still get executed.
A panic can propagate upwards to the caller functions in a goroutine
until the goroutine exits.
A panic will not propagate from one goroutine to another one.
If a panicking goroutine exits without being recovered, the whole program will crash.
</p>

<p>
The <code>panic</code> function is declared as <code>func panic(v interface{})</code>,
so a <code>panic</code> function call can takes an argument of any type.
The passed argument can also be a nil interface value.
</p>

<div>
For the following example,
even if the main goroutine is not panicking, the program still crashes.
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func doSomething() {
	defer fmt.Println("Hello!")
	panic("Bye!") // create a panic
	fmt.Println("Unreachable.")
}

func main() {
	c := make(chan bool)
	
	go func() {
		defer fmt.Println("Hi!")
		doSomething()
		fmt.Println("Unreachable.")
		c <- true
	}()
	
	<-c
}
</code></pre>

The output:
<pre class="output"><code>Hello!
Hi!
panic: Bye!

goroutine 1 [running]:
main.doSomething()
...
</code></pre>

<p>
After the new created goroutine panics in the <code>doSomething</code> function,
the two already deferred <code>fmt.Println</code> calls will be executed eventaully,
but the other two <code>fmt.Println</code> calls have not any chances to get executed.
</p>

Beside creating a panic by call the <code>panic</code> functions,
there are many scenarios Go runtime and standard packages
would create panics, such as
<ul>
<li>
	divide an integer by zero.
</li>
<li>
	dereference a nil pointer.
</li>
<li>
	call a nil function value.
</li>
<li>
	access elements of nil slices.
</li>
<li>
	put elements into nil maps.
</li>
<li>
	close (or send values to) a closed channel.
	(Please read <a href="channel.html">channels in Go</a> for details.)
</li>
</ul>
</div>

<h3>Recover</h3>

<p>
As above mentions, a panic can be revocered.
If the recovered panic is the only alive panic in the current panicking goroutine,
then the goroutine will restore to normal.
</p>

<p>
We can call the built-in <code>recover</code> function to recover a panic.
If a <code>recover</code> function call recover a panic,
then the return value of the <code>recover</code> function call
is an <code>interface{}</code> value which dynamic value is
a copy of the argument passed to the corresponding <code>panic</code> call.
</p>

<div>
The following example demos the idiomatic way to recover the panic in the last example.
Yes, <code>recover</code> calls must be placed in a deferred function to take effect.
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func doSomething() {
	defer func() {
		v := recover() // recover the panic.
		fmt.Println("Recover:", v)
		fmt.Println("Recovered, move on!")
	}()
	
	defer fmt.Println("Hello!")
	panic("Bye!") // create a panic
	fmt.Println("Still unreachable.")
}

func main() {
	c := make(chan bool)
	
	go func() {
		defer fmt.Println("Hi!")
		doSomething()
		fmt.Println("Reachable now.")
		c <- true
	}()
	
	<-c
}
</code></pre>

The output:
<pre class="output"><code>Hello!
Recover: Bye!
Recovered, move on!
Reachable now.
Hi!
</code></pre>

<p>
We can find that, after the goroutine execution exits the <code>doSomething</code>
function, the goroutine is not panicking any more,
so the following non-deferred statements will get executed as noraml.
The program will not crash.
</p>

<p>
Note, not any <code>recover</code> function call can recover alive panics.
A <code>recover</code> function call must be put at a proper place to
recover a specified panic. For more details, please read
<a href="panic-and-recover-more.html">this article</a>.
</p>

In a server program, We often use <code>recover</code> to avoid a
panicking client session goorutine crashing the whole program.

<pre class="line-numbers"><code class="language-go">package main

import "net"
import "log"
import "errors"

func main() {
	listener, err := net.Listen("tcp", ":12345")
	if err != nil {
		log.Fatalln(err)
	}
	for {
		conn, err := listener.Accept()
		if err != nil {
			log.Println(err)
		}
		go ClientHandler(conn)
	}
}

func ClientHandler(c net.Conn) {
	defer func() {
		// If we don't recover the potential panic, the
		// potential panic will make this program crash.
		if v := recover(); v != nil {
			log.Println("client handler panic:", v)
		}
		c.Close()
	}()
	
	panic(errors.New("just a demo.")) // a demo-purpose panic
}
</code></pre>

<p>
Start the server and run <code>telnet localhost 12345</code> in another terminal,
we can observe that the server will not crash down for the panics created in the client handler.
</p>

We can restart goroutines automatically on unexpected exits caused by panics
by catching/recovering the panics.

<pre class="line-numbers"><code class="language-go">package main

import "log"
import "time"

func shouldNotExit() {
	for {
		time.Sleep(time.Second) // simulate a workload
		// Simultate an unexpected panic.
		if time.Now().UnixNano() & 0x3 == 0 {
			panic("unexpected situation")
		}
	}
}

func NeverExit(name string, f func()) {
	defer func() {
		if v := recover(); v != nil {
			log.Println(name, "is crashed. Restart it now.")
			go NeverExit(name, f) // restart
		}
	}()
	f()
}

func main() {
	log.SetFlags(0)
	go NeverExit("job#A", shouldNotExit)
	go NeverExit("job#B", shouldNotExit)
	select{} // blocks here for ever
}
</code></pre>
</div>

<h3>Use Panic/Recover To Control Code Flow</h3>

<div>
<p>
Somtimes, we can use panic/recover as a way to
simulate crossing-functions long jump statements
and crossing-functions returns,
though generally this way is not recommended to use.
This way does harm for both code readibilty and execution efficiency.
The only benefit is sometimes it can make code look less verbose.
</p>

In the following example, once a panic is created in an inner function,
the exection will jump to the defer <code>recover</code> call.
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	n := func () (result int)  {
		defer func() {
			if v := recover(); v != nil {
				if n, ok := v.(int); ok {
					result = n
				}
			}
		}()
		
		result = func () int {
			func () {
				func () {
					// ...
					panic(123)
				}()
				// ...
			}()
			return 0
		}()
		// ...
		return
	}()
	fmt.Println(n) // 123
}
</code></pre>
</div>

<h3>Panic Or Return An Error?</h3>

<p>
At run time, there are often many circumstances which make the executions
in functions can't always be along the normal routes.
For such circumstances, is it better to panic or return an error?
Like many questions, the standard answer is "depends".
</p>

<p>
Generally, panics are for logic errors, human errors.
Logic errors are the errors which should never happen at run time.
It they are happen, there must be some bugs in the code.
On the other hand, non-logic errors are the erros which are hard to absolutely avoid at run time.
In other words, they are errors happening in reality.
Such errors should be handled properly to avoid crashing down programs.
</p>

<h3>More About Panic And Recover</h3>

<p>
Generally, the usages introduced in this article
is enough for using the panic and recover mechenism in daily Go programming.
To understand the panic and recover mechanism thoroughly,
please read <a href="panic-and-recover-more.html">the right places
to call <code>recover</code> function</a>.
</p>

<h3>Some Fatal Errors Are Not Panics And Unrecoverable</h3>

<p>
For the official Go compiler,
some fatal errors, such as stack overflow and out of memory errors, are not panics.
They are not recoverable. Once they happen, program will crash.
</p>
