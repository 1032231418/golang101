
all bool, numberic and string literals are untyped

0.
.0
0.0 default type is float64


2 + 1. will be deduced as two float64 values

3/2 + 1.


compile time evaluation

complex, len, cap, ....

type deduction (for appenda nd copy, nil argument will not get deduced)

===================================


	
	
const ss = 1 // untyped
x := [3]int{}
_ = x[1.0 << ss] // ok
var u = 1.0<<ss // ok
var _ = 1.0<<1 // ok



var s uint = 33 // typed variable
var u = 1.0<<s         // illegal: 1.0 has type float64, cannot shift
var u1 = 1.0<<s != 0   // illegal: 1.0 has type float64, cannot shift
var u2 = 1<<s != 1.0   // illegal: 1 has type float64, cannot shift
var v float32 = 1<<s   // illegal: 1 has type float32, cannot shift


const sss uint = 3 // typed costant
var u = 1.0<<sss         // ok
var u1 = 1.0<<sss != 0   // ok
var u2 = 1<<sss != 1.0   // ok
var v float32 = 1<<sss   // ok
var w int64 = 1.0<<33  // ok

=================================




<p>
The computation rules of a binary arithmetic operatior operation
depend on whether or not the two operands of the operaion 
are constants and typed.
The detailed computation rules cover all kinds of cases.
Some of the cases are uncommon and
the rules for them are some subtle for new gophers.
So, here, the current artile will not list the full detailed rules.

</p>





The computation rule depends on whether or not the two operands
of a binary arithmetic operatior operation are constants and typed.
<ul>
<li>
	When both of the two operands are typed constants,
	the computation happens at compile time.
	Compilation may fail if the result value overflows the result type.
	(The result type is the same as the types of the two operands.)
</li>
<li>
	When both of the two operands are untyped constants,
	the computation happens at compile time.
	The computation will never fail to compile,
	but the result value (still an untyped constant) may be not able to
	represent as any value of its default type.
</li>
<li>
	When one operand is an untyped constants and the other operand
	is a typed value, compilation will fail if the value of
	the untyped constant can't represent as any value of
	the type of the other (typed) value. In particular,
	<ul>
	<li>
		if the other (typed) value is a constant,
		the computation happens at compile time.
		Compilation will fail if the result value
		can't represent as any value of the type of
		the other (typed) value.
	</li>
	<li>
		if the other (typed) value is a non-constant,
		the computation happens at run time.
		Rounding and truncation (caused by overflow)
		may happen in the computation.
	</li>
	</ul>
</li>
<li>
	When both of the two operands are typed non-constant values,
	the computation happens at rune time.
	Compilation will never fail.
	Rounding and truncation (caused by overflow) may happen
	in the computation.
</li>
</ul>


=============================

three cases of operator operations, three different rules.
* both operands are non-constants
* both are constants and one is typed
* both are untyped constants


================================== From Go spec

The values of typed constants must always be accurately representable as values of the constant type.
Assignability of untyped constants requires, again, that the constant is representable as a T.

  Implementation restriction: Although numeric constants have arbitrary
  precision in the language, a compiler may implement them using an
  internal representation with limited precision. That said, every
  implementation must:

    ∙ Represent integer constants with at least 256 bits.
    ∙ Represent floating-point constants, including the parts of a
      complex constant, with a mantissa of at least 256 bits and a
      signed binary exponent of at least 16 bits.
    ∙ Give an error if unable to represent an integer constant
      precisely.
    ∙ Give an error if unable to represent a floating-point or complex
      constant due to overflow.
    ∙ Round to the nearest representable constant if unable to represent
      a floating-point or complex constant due to limits on precision.

  These requirements apply both to literal constants and to the result
  of evaluating constant expressions. 

It looks rounding is allowed, but truncation caused by overflow is not.

const N = 1 << 256
const F float32 = N // constant 3.40282e+38 overflows float32

const N = 1.8e+308
const F float64 = N // constant 1.8e+308 overflows float64

func main() {
	const k = 'A' << 32
	var _ = k // constant ('\x00' + 279172874240) overflows rune
}

func main() {
	const c = 'B' - 'A' + 0x7FFFFFFF
	fmt.Printf("%T \n", c - 1) // print "int32"
	var _ = c // constant ('\x00' + 2147483648) overflows rune
}

func main() {
  const N = 17000000000000000
  var a, b = float32(N), float64(N)
  println (float64(a) == b) // false
  println (int(a) == int(b)) // false
  println(a, b) // +1.700000e+016 +1.700000e+016
  println(int(a), int(b)) // 17000000248610816 17000000000000000
}

==================================

<p>
A basic value literal may be able to represent as values of many types.
These type may include the default type of the basic value literal or not.
</p>

For example,
<ul>
<li>
	the default type of <code>0x10000000000000000</code> (16 zeros)
	is <code>int</code>, 
	however it can't represent an <code>int</code> value.
	The reason is it is too large 
</li>
</ul>

<h3>Constant Expressions</h3>

<p>
If both the two operands of a binary operator operation are constants,
then we call the operator operation as a constant expression.
Similarly, if the only operand of a unary operator operation is a constant,
the unary operator operation is also a constant expression.
Expressions will be explained in the article
<a href="expressions-and-statements.html">expressions and statements</a>.
</p>

<p>
Constant expressions are evaluated at compile time.
The evaluation result of a constant expression is still a constant.
</p>

	Except for shift operations, if the operands of a binary numeric operation are different kinds of untyped constants, 
	, the operation and the result use the kind that appears later in this list: integer, rune, floating-point, complex.
	 For example, an untyped integer constant divided by an untyped complex constant yields an untyped complex constant. 

package main

import "fmt"

func main() {
	const a, b = 0xFFFFFFFF, 'a'
	var c = a + b // constant ('\x00' + 4294967392) overflows rune
	              // constant 4294967392 overflows rune
	var c int64 = a + b // ok
	// It looks the result type affect the constant expression comupation rule.
	fmt.Printf("%T, %x \n", c, c)
}

<h3>More About Constant Declarations</h3>

todo: how to represent max value of an unsigned integer: ^T(0).

todo: untyped values can be very large.

package main

func main() {
	println(y)
	println(x)
}

const a, b = 1e10000, 1e9999
var x = a/b // the default type of x is float64

const n = 1 << 100
var y uint8 = n >> 93


package main

import "unsafe"

func main() {
	println(MaxUint8_a == MaxUint8_b)
	println(MaxUint_a == MaxUint_b)
	println(MaxUint_a == MaxUint_c)
}

const MaxUint8_a uint8 = (1 << 8) - 1
const MaxUint_a uint = (1 << 64) - 1

const MaxUint8_b = ^uint8(0)
const MaxUint_b = (1 << 64) - 1

const MaxUint_c = (1 << (unsafe.Sizeof(1) * 8)) - 1

const MaxInt  = int(^uint(0) >> 1)

const a = uint8(255) + uint8(1) // error: 256 overflows uint8
const b = int8(-128) / int8(-1) // error, 128 overflows int8

===============


package main

func main() {
	const s1 uint = 33
	var a = 1.0 << s1 // ok, a is int
	var s2 uint = 33
	var b = 1.0 + s2 // ok, b is uint
	var _ = 1.0 << s2 // error
	var _ = 1 << s1 != 1.0 // ok
	var _ = 1 << s2 != 1.0 // error
	// ...
}

=================

Go spec:

var s uint = 33
var i = 1<<s           // 1 has type int
var j int32 = 1<<s     // 1 has type int32; j == 0
var k = uint64(1<<s)   // 1 has type uint64; k == 1<<33
var m int = 1.0<<s     // 1.0 has type int; m == 0 if ints are 32bits in size
var n = 1.0<<s == j    // 1.0 has type int32; n == true
var o = 1<<s == 2<<s   // 1 and 2 have type int; o == true if ints are 32bits in size
var p = 1<<s == 1<<33  // illegal if ints are 32bits in size: 1 has type int, but 1<<33 overflows int
var u = 1.0<<s         // illegal: 1.0 has type float64, cannot shift
var u1 = 1.0<<s != 0   // illegal: 1.0 has type float64, cannot shift
var u2 = 1<<s != 1.0   // illegal: 1 has type float64, cannot shift
var v float32 = 1<<s   // illegal: 1 has type float32, cannot shift
var w int64 = 1.0<<33  // 1.0<<33 is a constant shift expression

